/* automatically generated by rust-bindgen 0.66.1 */

use cairo_sys::cairo_t;
use harfbuzz_sys::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type guint16 = ::std::os::raw::c_ushort;
pub type gint32 = ::std::os::raw::c_int;
pub type guint32 = ::std::os::raw::c_uint;
pub type gsize = ::std::os::raw::c_ulong;
pub type gchar = ::std::os::raw::c_char;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guint = ::std::os::raw::c_uint;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type gconstpointer = *const ::std::os::raw::c_void;
pub type GEqualFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gboolean>;
pub type GDestroyNotify = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBytes {
    _unused: [u8; 0],
}
pub type GBytes = _GBytes;
pub type GQuark = guint32;
#[doc = " GError:\n @domain: error domain, e.g. %G_FILE_ERROR\n @code: error code, e.g. %G_FILE_ERROR_NOENT\n @message: human-readable informative error message\n\n The `GError` structure contains information about\n an error that has occurred."]
pub type GError = _GError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GError {
    pub domain: GQuark,
    pub code: gint,
    pub message: *mut gchar,
}
#[test]
fn bindgen_test_layout__GError() {
    const UNINIT: ::std::mem::MaybeUninit<_GError> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GError>(),
        16usize,
        concat!("Size of: ", stringify!(_GError))
    );
    assert_eq!(
        ::std::mem::align_of::<_GError>(),
        8usize,
        concat!("Alignment of ", stringify!(_GError))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(message)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GData {
    _unused: [u8; 0],
}
pub type GData = _GData;
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
#[test]
fn bindgen_test_layout__GList() {
    const UNINIT: ::std::mem::MaybeUninit<_GList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GList>(),
        24usize,
        concat!("Size of: ", stringify!(_GList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(prev)
        )
    );
}
pub type GSList = _GSList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
#[test]
fn bindgen_test_layout__GSList() {
    const UNINIT: ::std::mem::MaybeUninit<_GSList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSList>(),
        16usize,
        concat!("Size of: ", stringify!(_GSList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " gunichar:\n\n A type which can hold any UTF-32 or UCS-4 character code,\n also known as a Unicode code point.\n\n If you want to produce the UTF-8 representation of a #gunichar,\n use g_ucs4_to_utf8(). See also g_utf8_to_ucs4() for the reverse\n process.\n\n To print/scan values of this type as integer, use\n %G_GINT32_MODIFIER and/or %G_GUINT32_FORMAT.\n\n The notation to express a Unicode code point in running text is\n as a hexadecimal number with four to six digits and uppercase\n letters, prefixed by the string \"U+\". Leading zeros are omitted,\n unless the code point would have fewer than four hexadecimal digits.\n For example, \"U+0041 LATIN CAPITAL LETTER A\". To print a code point\n in the U+-notation, use the format string \"U+\\%04\"G_GINT32_FORMAT\"X\".\n To scan, use the format string \"U+\\%06\"G_GINT32_FORMAT\"X\".\n\n |[\n gunichar c;\n sscanf (\"U+0041\", \"U+%06\"G_GINT32_FORMAT\"X\", &amp;c)\n g_print (\"Read U+%04\"G_GINT32_FORMAT\"X\", c);\n ]|"]
pub type gunichar = guint32;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INVALID_CODE: GUnicodeScript = -1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COMMON: GUnicodeScript = 0;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INHERITED: GUnicodeScript = 1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARABIC: GUnicodeScript = 2;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARMENIAN: GUnicodeScript = 3;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BENGALI: GUnicodeScript = 4;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BOPOMOFO: GUnicodeScript = 5;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHEROKEE: GUnicodeScript = 6;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COPTIC: GUnicodeScript = 7;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYRILLIC: GUnicodeScript = 8;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DESERET: GUnicodeScript = 9;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DEVANAGARI: GUnicodeScript = 10;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ETHIOPIC: GUnicodeScript = 11;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GEORGIAN: GUnicodeScript = 12;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GOTHIC: GUnicodeScript = 13;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GREEK: GUnicodeScript = 14;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUJARATI: GUnicodeScript = 15;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GURMUKHI: GUnicodeScript = 16;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HAN: GUnicodeScript = 17;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANGUL: GUnicodeScript = 18;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HEBREW: GUnicodeScript = 19;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HIRAGANA: GUnicodeScript = 20;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KANNADA: GUnicodeScript = 21;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KATAKANA: GUnicodeScript = 22;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHMER: GUnicodeScript = 23;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LAO: GUnicodeScript = 24;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LATIN: GUnicodeScript = 25;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MALAYALAM: GUnicodeScript = 26;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MONGOLIAN: GUnicodeScript = 27;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MYANMAR: GUnicodeScript = 28;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OGHAM: GUnicodeScript = 29;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_ITALIC: GUnicodeScript = 30;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ORIYA: GUnicodeScript = 31;
pub const GUnicodeScript_G_UNICODE_SCRIPT_RUNIC: GUnicodeScript = 32;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SINHALA: GUnicodeScript = 33;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYRIAC: GUnicodeScript = 34;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAMIL: GUnicodeScript = 35;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TELUGU: GUnicodeScript = 36;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAANA: GUnicodeScript = 37;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAI: GUnicodeScript = 38;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIBETAN: GUnicodeScript = 39;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: GUnicodeScript = 40;
pub const GUnicodeScript_G_UNICODE_SCRIPT_YI: GUnicodeScript = 41;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGALOG: GUnicodeScript = 42;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANUNOO: GUnicodeScript = 43;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUHID: GUnicodeScript = 44;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGBANWA: GUnicodeScript = 45;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAILLE: GUnicodeScript = 46;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRIOT: GUnicodeScript = 47;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LIMBU: GUnicodeScript = 48;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSMANYA: GUnicodeScript = 49;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHAVIAN: GUnicodeScript = 50;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_B: GUnicodeScript = 51;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_LE: GUnicodeScript = 52;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UGARITIC: GUnicodeScript = 53;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEW_TAI_LUE: GUnicodeScript = 54;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUGINESE: GUnicodeScript = 55;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GLAGOLITIC: GUnicodeScript = 56;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIFINAGH: GUnicodeScript = 57;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYLOTI_NAGRI: GUnicodeScript = 58;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERSIAN: GUnicodeScript = 59;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHAROSHTHI: GUnicodeScript = 60;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UNKNOWN: GUnicodeScript = 61;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BALINESE: GUnicodeScript = 62;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CUNEIFORM: GUnicodeScript = 63;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHOENICIAN: GUnicodeScript = 64;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHAGS_PA: GUnicodeScript = 65;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NKO: GUnicodeScript = 66;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAYAH_LI: GUnicodeScript = 67;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LEPCHA: GUnicodeScript = 68;
pub const GUnicodeScript_G_UNICODE_SCRIPT_REJANG: GUnicodeScript = 69;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SUNDANESE: GUnicodeScript = 70;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAURASHTRA: GUnicodeScript = 71;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAM: GUnicodeScript = 72;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OL_CHIKI: GUnicodeScript = 73;
pub const GUnicodeScript_G_UNICODE_SCRIPT_VAI: GUnicodeScript = 74;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CARIAN: GUnicodeScript = 75;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYCIAN: GUnicodeScript = 76;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYDIAN: GUnicodeScript = 77;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AVESTAN: GUnicodeScript = 78;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BAMUM: GUnicodeScript = 79;
pub const GUnicodeScript_G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: GUnicodeScript = 80;
pub const GUnicodeScript_G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: GUnicodeScript = 81;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: GUnicodeScript = 82;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: GUnicodeScript = 83;
pub const GUnicodeScript_G_UNICODE_SCRIPT_JAVANESE: GUnicodeScript = 84;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAITHI: GUnicodeScript = 85;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LISU: GUnicodeScript = 86;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEETEI_MAYEK: GUnicodeScript = 87;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: GUnicodeScript = 88;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_TURKIC: GUnicodeScript = 89;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAMARITAN: GUnicodeScript = 90;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_THAM: GUnicodeScript = 91;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_VIET: GUnicodeScript = 92;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BATAK: GUnicodeScript = 93;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAHMI: GUnicodeScript = 94;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANDAIC: GUnicodeScript = 95;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAKMA: GUnicodeScript = 96;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_CURSIVE: GUnicodeScript = 97;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: GUnicodeScript = 98;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MIAO: GUnicodeScript = 99;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHARADA: GUnicodeScript = 100;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SORA_SOMPENG: GUnicodeScript = 101;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAKRI: GUnicodeScript = 102;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BASSA_VAH: GUnicodeScript = 103;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: GUnicodeScript = 104;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DUPLOYAN: GUnicodeScript = 105;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELBASAN: GUnicodeScript = 106;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GRANTHA: GUnicodeScript = 107;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHOJKI: GUnicodeScript = 108;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHUDAWADI: GUnicodeScript = 109;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_A: GUnicodeScript = 110;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAHAJANI: GUnicodeScript = 111;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANICHAEAN: GUnicodeScript = 112;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MENDE_KIKAKUI: GUnicodeScript = 113;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MODI: GUnicodeScript = 114;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MRO: GUnicodeScript = 115;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NABATAEAN: GUnicodeScript = 116;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: GUnicodeScript = 117;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERMIC: GUnicodeScript = 118;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAHAWH_HMONG: GUnicodeScript = 119;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PALMYRENE: GUnicodeScript = 120;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAU_CIN_HAU: GUnicodeScript = 121;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PSALTER_PAHLAVI: GUnicodeScript = 122;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIDDHAM: GUnicodeScript = 123;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIRHUTA: GUnicodeScript = 124;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WARANG_CITI: GUnicodeScript = 125;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AHOM: GUnicodeScript = 126;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: GUnicodeScript = 127;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HATRAN: GUnicodeScript = 128;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MULTANI: GUnicodeScript = 129;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_HUNGARIAN: GUnicodeScript = 130;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIGNWRITING: GUnicodeScript = 131;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ADLAM: GUnicodeScript = 132;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BHAIKSUKI: GUnicodeScript = 133;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MARCHEN: GUnicodeScript = 134;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEWA: GUnicodeScript = 135;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSAGE: GUnicodeScript = 136;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGUT: GUnicodeScript = 137;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MASARAM_GONDI: GUnicodeScript = 138;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NUSHU: GUnicodeScript = 139;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SOYOMBO: GUnicodeScript = 140;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ZANABAZAR_SQUARE: GUnicodeScript = 141;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DOGRA: GUnicodeScript = 142;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUNJALA_GONDI: GUnicodeScript = 143;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANIFI_ROHINGYA: GUnicodeScript = 144;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAKASAR: GUnicodeScript = 145;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEDEFAIDRIN: GUnicodeScript = 146;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOGDIAN: GUnicodeScript = 147;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SOGDIAN: GUnicodeScript = 148;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELYMAIC: GUnicodeScript = 149;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NANDINAGARI: GUnicodeScript = 150;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: GUnicodeScript = 151;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WANCHO: GUnicodeScript = 152;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHORASMIAN: GUnicodeScript = 153;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DIVES_AKURU: GUnicodeScript = 154;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT: GUnicodeScript = 155;
pub const GUnicodeScript_G_UNICODE_SCRIPT_YEZIDI: GUnicodeScript = 156;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRO_MINOAN: GUnicodeScript = 157;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_UYGHUR: GUnicodeScript = 158;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGSA: GUnicodeScript = 159;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TOTO: GUnicodeScript = 160;
pub const GUnicodeScript_G_UNICODE_SCRIPT_VITHKUQI: GUnicodeScript = 161;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MATH: GUnicodeScript = 162;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAWI: GUnicodeScript = 163;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NAG_MUNDARI: GUnicodeScript = 164;
#[doc = " GUnicodeScript:\n @G_UNICODE_SCRIPT_INVALID_CODE:\n                               a value never returned from g_unichar_get_script()\n @G_UNICODE_SCRIPT_COMMON:     a character used by multiple different scripts\n @G_UNICODE_SCRIPT_INHERITED:  a mark glyph that takes its script from the\n                               base glyph to which it is attached\n @G_UNICODE_SCRIPT_ARABIC:     Arabic\n @G_UNICODE_SCRIPT_ARMENIAN:   Armenian\n @G_UNICODE_SCRIPT_BENGALI:    Bengali\n @G_UNICODE_SCRIPT_BOPOMOFO:   Bopomofo\n @G_UNICODE_SCRIPT_CHEROKEE:   Cherokee\n @G_UNICODE_SCRIPT_COPTIC:     Coptic\n @G_UNICODE_SCRIPT_CYRILLIC:   Cyrillic\n @G_UNICODE_SCRIPT_DESERET:    Deseret\n @G_UNICODE_SCRIPT_DEVANAGARI: Devanagari\n @G_UNICODE_SCRIPT_ETHIOPIC:   Ethiopic\n @G_UNICODE_SCRIPT_GEORGIAN:   Georgian\n @G_UNICODE_SCRIPT_GOTHIC:     Gothic\n @G_UNICODE_SCRIPT_GREEK:      Greek\n @G_UNICODE_SCRIPT_GUJARATI:   Gujarati\n @G_UNICODE_SCRIPT_GURMUKHI:   Gurmukhi\n @G_UNICODE_SCRIPT_HAN:        Han\n @G_UNICODE_SCRIPT_HANGUL:     Hangul\n @G_UNICODE_SCRIPT_HEBREW:     Hebrew\n @G_UNICODE_SCRIPT_HIRAGANA:   Hiragana\n @G_UNICODE_SCRIPT_KANNADA:    Kannada\n @G_UNICODE_SCRIPT_KATAKANA:   Katakana\n @G_UNICODE_SCRIPT_KHMER:      Khmer\n @G_UNICODE_SCRIPT_LAO:        Lao\n @G_UNICODE_SCRIPT_LATIN:      Latin\n @G_UNICODE_SCRIPT_MALAYALAM:  Malayalam\n @G_UNICODE_SCRIPT_MONGOLIAN:  Mongolian\n @G_UNICODE_SCRIPT_MYANMAR:    Myanmar\n @G_UNICODE_SCRIPT_OGHAM:      Ogham\n @G_UNICODE_SCRIPT_OLD_ITALIC: Old Italic\n @G_UNICODE_SCRIPT_ORIYA:      Oriya\n @G_UNICODE_SCRIPT_RUNIC:      Runic\n @G_UNICODE_SCRIPT_SINHALA:    Sinhala\n @G_UNICODE_SCRIPT_SYRIAC:     Syriac\n @G_UNICODE_SCRIPT_TAMIL:      Tamil\n @G_UNICODE_SCRIPT_TELUGU:     Telugu\n @G_UNICODE_SCRIPT_THAANA:     Thaana\n @G_UNICODE_SCRIPT_THAI:       Thai\n @G_UNICODE_SCRIPT_TIBETAN:    Tibetan\n @G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL:\n                               Canadian Aboriginal\n @G_UNICODE_SCRIPT_YI:         Yi\n @G_UNICODE_SCRIPT_TAGALOG:    Tagalog\n @G_UNICODE_SCRIPT_HANUNOO:    Hanunoo\n @G_UNICODE_SCRIPT_BUHID:      Buhid\n @G_UNICODE_SCRIPT_TAGBANWA:   Tagbanwa\n @G_UNICODE_SCRIPT_BRAILLE:    Braille\n @G_UNICODE_SCRIPT_CYPRIOT:    Cypriot\n @G_UNICODE_SCRIPT_LIMBU:      Limbu\n @G_UNICODE_SCRIPT_OSMANYA:    Osmanya\n @G_UNICODE_SCRIPT_SHAVIAN:    Shavian\n @G_UNICODE_SCRIPT_LINEAR_B:   Linear B\n @G_UNICODE_SCRIPT_TAI_LE:     Tai Le\n @G_UNICODE_SCRIPT_UGARITIC:   Ugaritic\n @G_UNICODE_SCRIPT_NEW_TAI_LUE:\n                               New Tai Lue\n @G_UNICODE_SCRIPT_BUGINESE:   Buginese\n @G_UNICODE_SCRIPT_GLAGOLITIC: Glagolitic\n @G_UNICODE_SCRIPT_TIFINAGH:   Tifinagh\n @G_UNICODE_SCRIPT_SYLOTI_NAGRI:\n                               Syloti Nagri\n @G_UNICODE_SCRIPT_OLD_PERSIAN:\n                               Old Persian\n @G_UNICODE_SCRIPT_KHAROSHTHI: Kharoshthi\n @G_UNICODE_SCRIPT_UNKNOWN:    an unassigned code point\n @G_UNICODE_SCRIPT_BALINESE:   Balinese\n @G_UNICODE_SCRIPT_CUNEIFORM:  Cuneiform\n @G_UNICODE_SCRIPT_PHOENICIAN: Phoenician\n @G_UNICODE_SCRIPT_PHAGS_PA:   Phags-pa\n @G_UNICODE_SCRIPT_NKO:        N'Ko\n @G_UNICODE_SCRIPT_KAYAH_LI:   Kayah Li. Since 2.16.3\n @G_UNICODE_SCRIPT_LEPCHA:     Lepcha. Since 2.16.3\n @G_UNICODE_SCRIPT_REJANG:     Rejang. Since 2.16.3\n @G_UNICODE_SCRIPT_SUNDANESE:  Sundanese. Since 2.16.3\n @G_UNICODE_SCRIPT_SAURASHTRA: Saurashtra. Since 2.16.3\n @G_UNICODE_SCRIPT_CHAM:       Cham. Since 2.16.3\n @G_UNICODE_SCRIPT_OL_CHIKI:   Ol Chiki. Since 2.16.3\n @G_UNICODE_SCRIPT_VAI:        Vai. Since 2.16.3\n @G_UNICODE_SCRIPT_CARIAN:     Carian. Since 2.16.3\n @G_UNICODE_SCRIPT_LYCIAN:     Lycian. Since 2.16.3\n @G_UNICODE_SCRIPT_LYDIAN:     Lydian. Since 2.16.3\n @G_UNICODE_SCRIPT_AVESTAN:    Avestan. Since 2.26\n @G_UNICODE_SCRIPT_BAMUM:      Bamum. Since 2.26\n @G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS:\n                               Egyptian Hieroglpyhs. Since 2.26\n @G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC:\n                               Imperial Aramaic. Since 2.26\n @G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI:\n                               Inscriptional Pahlavi. Since 2.26\n @G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN:\n                               Inscriptional Parthian. Since 2.26\n @G_UNICODE_SCRIPT_JAVANESE:   Javanese. Since 2.26\n @G_UNICODE_SCRIPT_KAITHI:     Kaithi. Since 2.26\n @G_UNICODE_SCRIPT_LISU:       Lisu. Since 2.26\n @G_UNICODE_SCRIPT_MEETEI_MAYEK:\n                               Meetei Mayek. Since 2.26\n @G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN:\n                               Old South Arabian. Since 2.26\n @G_UNICODE_SCRIPT_OLD_TURKIC: Old Turkic. Since 2.28\n @G_UNICODE_SCRIPT_SAMARITAN:  Samaritan. Since 2.26\n @G_UNICODE_SCRIPT_TAI_THAM:   Tai Tham. Since 2.26\n @G_UNICODE_SCRIPT_TAI_VIET:   Tai Viet. Since 2.26\n @G_UNICODE_SCRIPT_BATAK:      Batak. Since 2.28\n @G_UNICODE_SCRIPT_BRAHMI:     Brahmi. Since 2.28\n @G_UNICODE_SCRIPT_MANDAIC:    Mandaic. Since 2.28\n @G_UNICODE_SCRIPT_CHAKMA:               Chakma. Since: 2.32\n @G_UNICODE_SCRIPT_MEROITIC_CURSIVE:     Meroitic Cursive. Since: 2.32\n @G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: Meroitic Hieroglyphs. Since: 2.32\n @G_UNICODE_SCRIPT_MIAO:                 Miao. Since: 2.32\n @G_UNICODE_SCRIPT_SHARADA:              Sharada. Since: 2.32\n @G_UNICODE_SCRIPT_SORA_SOMPENG:         Sora Sompeng. Since: 2.32\n @G_UNICODE_SCRIPT_TAKRI:                Takri. Since: 2.32\n @G_UNICODE_SCRIPT_BASSA_VAH:            Bassa. Since: 2.42\n @G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN:   Caucasian Albanian. Since: 2.42\n @G_UNICODE_SCRIPT_DUPLOYAN:             Duployan. Since: 2.42\n @G_UNICODE_SCRIPT_ELBASAN:              Elbasan. Since: 2.42\n @G_UNICODE_SCRIPT_GRANTHA:              Grantha. Since: 2.42\n @G_UNICODE_SCRIPT_KHOJKI:               Kjohki. Since: 2.42\n @G_UNICODE_SCRIPT_KHUDAWADI:            Khudawadi, Sindhi. Since: 2.42\n @G_UNICODE_SCRIPT_LINEAR_A:             Linear A. Since: 2.42\n @G_UNICODE_SCRIPT_MAHAJANI:             Mahajani. Since: 2.42\n @G_UNICODE_SCRIPT_MANICHAEAN:           Manichaean. Since: 2.42\n @G_UNICODE_SCRIPT_MENDE_KIKAKUI:        Mende Kikakui. Since: 2.42\n @G_UNICODE_SCRIPT_MODI:                 Modi. Since: 2.42\n @G_UNICODE_SCRIPT_MRO:                  Mro. Since: 2.42\n @G_UNICODE_SCRIPT_NABATAEAN:            Nabataean. Since: 2.42\n @G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN:    Old North Arabian. Since: 2.42\n @G_UNICODE_SCRIPT_OLD_PERMIC:           Old Permic. Since: 2.42\n @G_UNICODE_SCRIPT_PAHAWH_HMONG:         Pahawh Hmong. Since: 2.42\n @G_UNICODE_SCRIPT_PALMYRENE:            Palmyrene. Since: 2.42\n @G_UNICODE_SCRIPT_PAU_CIN_HAU:          Pau Cin Hau. Since: 2.42\n @G_UNICODE_SCRIPT_PSALTER_PAHLAVI:      Psalter Pahlavi. Since: 2.42\n @G_UNICODE_SCRIPT_SIDDHAM:              Siddham. Since: 2.42\n @G_UNICODE_SCRIPT_TIRHUTA:              Tirhuta. Since: 2.42\n @G_UNICODE_SCRIPT_WARANG_CITI:          Warang Citi. Since: 2.42\n @G_UNICODE_SCRIPT_AHOM:                 Ahom. Since: 2.48\n @G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: Anatolian Hieroglyphs. Since: 2.48\n @G_UNICODE_SCRIPT_HATRAN:               Hatran. Since: 2.48\n @G_UNICODE_SCRIPT_MULTANI:              Multani. Since: 2.48\n @G_UNICODE_SCRIPT_OLD_HUNGARIAN:        Old Hungarian. Since: 2.48\n @G_UNICODE_SCRIPT_SIGNWRITING:          Signwriting. Since: 2.48\n @G_UNICODE_SCRIPT_ADLAM:                Adlam. Since: 2.50\n @G_UNICODE_SCRIPT_BHAIKSUKI:            Bhaiksuki. Since: 2.50\n @G_UNICODE_SCRIPT_MARCHEN:              Marchen. Since: 2.50\n @G_UNICODE_SCRIPT_NEWA:                 Newa. Since: 2.50\n @G_UNICODE_SCRIPT_OSAGE:                Osage. Since: 2.50\n @G_UNICODE_SCRIPT_TANGUT:               Tangut. Since: 2.50\n @G_UNICODE_SCRIPT_MASARAM_GONDI:        Masaram Gondi. Since: 2.54\n @G_UNICODE_SCRIPT_NUSHU:                Nushu. Since: 2.54\n @G_UNICODE_SCRIPT_SOYOMBO:              Soyombo. Since: 2.54\n @G_UNICODE_SCRIPT_ZANABAZAR_SQUARE:     Zanabazar Square. Since: 2.54\n @G_UNICODE_SCRIPT_DOGRA:                Dogra. Since: 2.58\n @G_UNICODE_SCRIPT_GUNJALA_GONDI:        Gunjala Gondi. Since: 2.58\n @G_UNICODE_SCRIPT_HANIFI_ROHINGYA:      Hanifi Rohingya. Since: 2.58\n @G_UNICODE_SCRIPT_MAKASAR:              Makasar. Since: 2.58\n @G_UNICODE_SCRIPT_MEDEFAIDRIN:          Medefaidrin. Since: 2.58\n @G_UNICODE_SCRIPT_OLD_SOGDIAN:          Old Sogdian. Since: 2.58\n @G_UNICODE_SCRIPT_SOGDIAN:              Sogdian. Since: 2.58\n @G_UNICODE_SCRIPT_ELYMAIC:              Elym. Since: 2.62\n @G_UNICODE_SCRIPT_NANDINAGARI:          Nand. Since: 2.62\n @G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: Rohg. Since: 2.62\n @G_UNICODE_SCRIPT_WANCHO:               Wcho. Since: 2.62\n @G_UNICODE_SCRIPT_CHORASMIAN:           Chorasmian. Since: 2.66\n @G_UNICODE_SCRIPT_DIVES_AKURU:          Dives Akuru. Since: 2.66\n @G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT:  Khitan small script. Since: 2.66\n @G_UNICODE_SCRIPT_YEZIDI:               Yezidi. Since: 2.66\n @G_UNICODE_SCRIPT_CYPRO_MINOAN:         Cypro-Minoan. Since: 2.72\n @G_UNICODE_SCRIPT_OLD_UYGHUR:           Old Uyghur. Since: 2.72\n @G_UNICODE_SCRIPT_TANGSA:               Tangsa. Since: 2.72\n @G_UNICODE_SCRIPT_TOTO:                 Toto. Since: 2.72\n @G_UNICODE_SCRIPT_VITHKUQI:             Vithkuqi. Since: 2.72\n @G_UNICODE_SCRIPT_MATH:                 Mathematical notation. Since: 2.72\n @G_UNICODE_SCRIPT_KAWI:                 Kawi. Since 2.74\n @G_UNICODE_SCRIPT_NAG_MUNDARI:          Nag Mundari. Since 2.74\n\n The #GUnicodeScript enumeration identifies different writing\n systems. The values correspond to the names as defined in the\n Unicode standard. The enumeration has been added in GLib 2.14,\n and is interchangeable with #PangoScript.\n\n Note that new types may be added in the future. Applications\n should be ready to handle unknown values.\n See [Unicode Standard Annex #24: Script names](http://www.unicode.org/reports/tr24/)."]
pub type GUnicodeScript = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParseContext {
    _unused: [u8; 0],
}
#[doc = " GMarkupParseContext:\n\n A parse context is used to parse a stream of bytes that\n you expect to contain marked-up text.\n\n See g_markup_parse_context_new(), #GMarkupParser, and so\n on for more details."]
pub type GMarkupParseContext = _GMarkupParseContext;
pub type GType = gsize;
#[doc = " GTypeClass:\n\n An opaque structure used as the base of all classes."]
pub type GTypeClass = _GTypeClass;
#[doc = " GTypeInstance:\n\n An opaque structure used as the base of all type instances."]
pub type GTypeInstance = _GTypeInstance;
#[doc = " GTypeClass:\n\n An opaque structure used as the base of all classes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeClass {
    pub g_type: GType,
}
#[test]
fn bindgen_test_layout__GTypeClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeClass>(),
        8usize,
        concat!("Size of: ", stringify!(_GTypeClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeClass),
            "::",
            stringify!(g_type)
        )
    );
}
#[doc = " GTypeInstance:\n\n An opaque structure used as the base of all type instances."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInstance {
    pub g_class: *mut GTypeClass,
}
#[test]
fn bindgen_test_layout__GTypeInstance() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeInstance> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeInstance>(),
        8usize,
        concat!("Size of: ", stringify!(_GTypeInstance))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeInstance>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeInstance))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInstance),
            "::",
            stringify!(g_class)
        )
    );
}
#[doc = " GObject:\n\n The base object type.\n\n All the fields in the `GObject` structure are private to the implementation\n and should never be accessed directly.\n\n Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the\n alignment of the largest basic GLib type (typically this is #guint64 or\n #gdouble). If you need larger alignment for an element in a #GObject, you\n should allocate it on the heap (aligned), or arrange for your #GObject to be\n appropriately padded. This guarantee applies to the #GObject (or derived)\n struct, the #GObjectClass (or derived) struct, and any private data allocated\n by G_ADD_PRIVATE()."]
pub type GObject = _GObject;
#[doc = " GObject:\n\n The base object type.\n\n All the fields in the `GObject` structure are private to the implementation\n and should never be accessed directly.\n\n Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the\n alignment of the largest basic GLib type (typically this is #guint64 or\n #gdouble). If you need larger alignment for an element in a #GObject, you\n should allocate it on the heap (aligned), or arrange for your #GObject to be\n appropriately padded. This guarantee applies to the #GObject (or derived)\n struct, the #GObjectClass (or derived) struct, and any private data allocated\n by G_ADD_PRIVATE()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObject {
    pub g_type_instance: GTypeInstance,
    pub ref_count: guint,
    pub qdata: *mut GData,
}
#[test]
fn bindgen_test_layout__GObject() {
    const UNINIT: ::std::mem::MaybeUninit<_GObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GObject>(),
        24usize,
        concat!("Size of: ", stringify!(_GObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(g_type_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qdata) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(qdata)
        )
    );
}
#[doc = " Pango2LogAttr:\n @is_line_break: if set, can break line in front of character\n @is_mandatory_break: if set, must break line in front of character\n @is_char_break: if set, can break here when doing character wrapping\n @is_white: is whitespace character\n @is_cursor_position: if set, cursor can appear in front of character.\n   i.e. this is a grapheme boundary, or the first character in the text.\n   This flag implements Unicode's\n   [Grapheme Cluster Boundaries](http://www.unicode.org/reports/tr29/)\n   semantics.\n @is_word_start: is first character in a word\n @is_word_end: is first non-word char after a word\n   Note that in degenerate cases, you could have both @is_word_start\n   and @is_word_end set for some character.\n @is_sentence_boundary: is a sentence boundary.\n   There are two ways to divide sentences. The first assigns all\n   inter-sentence whitespace/control/format chars to some sentence,\n   so all chars are in some sentence; @is_sentence_boundary denotes\n   the boundaries there. The second way doesn't assign\n   between-sentence spaces, etc. to any sentence, so\n   @is_sentence_start/@is_sentence_end mark the boundaries of those sentences.\n @is_sentence_start: is first character in a sentence\n @is_sentence_end: is first char after a sentence.\n   Note that in degenerate cases, you could have both @is_sentence_start\n   and @is_sentence_end set for some character. (e.g. no space after a\n   period, so the next sentence starts right away)\n @backspace_deletes_character: if set, backspace deletes one character\n   rather than the entire grapheme cluster. This field is only meaningful\n   on grapheme boundaries (where @is_cursor_position is set). In some languages,\n   the full grapheme (e.g. letter + diacritics) is considered a unit, while in\n   others, each decomposed character in the grapheme is a unit. In the default\n   implementation of [func@default_break], this bit is set on all grapheme\n   boundaries except those following Latin, Cyrillic or Greek base characters.\n @is_expandable_space: is a whitespace character that can possibly be\n   expanded for justification purposes.\n @is_word_boundary: is a word boundary, as defined by UAX#29.\n   More specifically, means that this is not a position in the middle of a word.\n   For example, both sides of a punctuation mark are considered word boundaries.\n   This flag is particularly useful when selecting text word-by-word. This flag\n   implements Unicode's [Word Boundaries](http://www.unicode.org/reports/tr29/)\n   semantics.\n @break_inserts_hyphen: when breaking lines before this char, insert a hyphen.\n @break_removes_preceding: when breaking lines before this char, remove the\n   preceding char.\n\n The `Pango2LogAttr` structure stores information about the attributes of a\n single character."]
pub type Pango2LogAttr = _Pango2LogAttr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2FontDescription {
    _unused: [u8; 0],
}
pub type Pango2FontDescription = _Pango2FontDescription;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2Font {
    _unused: [u8; 0],
}
pub type Pango2Font = _Pango2Font;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2FontFace {
    _unused: [u8; 0],
}
pub type Pango2FontFace = _Pango2FontFace;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2FontFamily {
    _unused: [u8; 0],
}
pub type Pango2FontFamily = _Pango2FontFamily;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2FontMap {
    _unused: [u8; 0],
}
pub type Pango2FontMap = _Pango2FontMap;
#[doc = " Pango2Rectangle:\n @x: X coordinate of the left side of the rectangle.\n @y: Y coordinate of the the top side of the rectangle.\n @width: width of the rectangle.\n @height: height of the rectangle.\n\n The `Pango2Rectangle` structure represents a rectangle.\n\n `Pango2Rectangle` is frequently used to represent the logical or ink\n extents of a single glyph or section of text. (See, for instance,\n [method@Pango2.Font.get_glyph_extents].)"]
pub type Pango2Rectangle = _Pango2Rectangle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2Context {
    _unused: [u8; 0],
}
pub type Pango2Context = _Pango2Context;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2Language {
    _unused: [u8; 0],
}
pub type Pango2Language = _Pango2Language;
#[doc = " Pango2Glyph:\n\n A `Pango2Glyph` represents a single glyph in the output form of a string."]
pub type Pango2Glyph = guint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2Lines {
    _unused: [u8; 0],
}
pub type Pango2Lines = _Pango2Lines;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2Run {
    _unused: [u8; 0],
}
pub type Pango2Run = _Pango2Run;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2Line {
    _unused: [u8; 0],
}
pub type Pango2Line = _Pango2Line;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2LineIter {
    _unused: [u8; 0],
}
pub type Pango2LineIter = _Pango2LineIter;
extern "C" {
    pub fn pango2_units_from_double(d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_units_to_double(i: ::std::os::raw::c_int) -> f64;
}
#[doc = " Pango2Rectangle:\n @x: X coordinate of the left side of the rectangle.\n @y: Y coordinate of the the top side of the rectangle.\n @width: width of the rectangle.\n @height: height of the rectangle.\n\n The `Pango2Rectangle` structure represents a rectangle.\n\n `Pango2Rectangle` is frequently used to represent the logical or ink\n extents of a single glyph or section of text. (See, for instance,\n [method@Pango2.Font.get_glyph_extents].)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2Rectangle {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__Pango2Rectangle() {
    const UNINIT: ::std::mem::MaybeUninit<_Pango2Rectangle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Pango2Rectangle>(),
        16usize,
        concat!("Size of: ", stringify!(_Pango2Rectangle))
    );
    assert_eq!(
        ::std::mem::align_of::<_Pango2Rectangle>(),
        4usize,
        concat!("Alignment of ", stringify!(_Pango2Rectangle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2Rectangle),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2Rectangle),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2Rectangle),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2Rectangle),
            "::",
            stringify!(height)
        )
    );
}
extern "C" {
    pub fn pango2_extents_to_pixels(inclusive: *mut Pango2Rectangle, nearest: *mut Pango2Rectangle);
}
pub const Pango2Direction_PANGO2_DIRECTION_LTR: Pango2Direction = 0;
pub const Pango2Direction_PANGO2_DIRECTION_RTL: Pango2Direction = 1;
pub const Pango2Direction_PANGO2_DIRECTION_WEAK_LTR: Pango2Direction = 2;
pub const Pango2Direction_PANGO2_DIRECTION_WEAK_RTL: Pango2Direction = 3;
pub const Pango2Direction_PANGO2_DIRECTION_NEUTRAL: Pango2Direction = 4;
#[doc = " Pango2Direction:\n @PANGO2_DIRECTION_LTR: A strong left-to-right direction\n @PANGO2_DIRECTION_RTL: A strong right-to-left direction\n @PANGO2_DIRECTION_WEAK_LTR: A weak left-to-right direction\n @PANGO2_DIRECTION_WEAK_RTL: A weak right-to-left direction\n @PANGO2_DIRECTION_NEUTRAL: No direction specified\n\n `Pango2Direction` represents a direction in the Unicode bidirectional\n algorithm.\n\n Not every value in this enumeration makes sense for every usage of\n `Pango2Direction`; for example, the direction of characters cannot be\n `PANGO2_DIRECTION_WEAK_LTR` or `PANGO2_DIRECTION_WEAK_RTL`, since every\n character is either neutral or has a strong direction; on the other hand\n `PANGO2_DIRECTION_NEUTRAL` doesn't make sense to pass to [func@itemize].\n\n See `Pango2Gravity` for how vertical text is handled in Pango2.\n\n If you are interested in text direction, you should really use\n [fribidi](http://fribidi.org/) directly. `Pango2Direction` is only\n retained because it is used in some public apis."]
pub type Pango2Direction = ::std::os::raw::c_uint;
pub const Pango2Gravity_PANGO2_GRAVITY_SOUTH: Pango2Gravity = 0;
pub const Pango2Gravity_PANGO2_GRAVITY_EAST: Pango2Gravity = 1;
pub const Pango2Gravity_PANGO2_GRAVITY_NORTH: Pango2Gravity = 2;
pub const Pango2Gravity_PANGO2_GRAVITY_WEST: Pango2Gravity = 3;
pub const Pango2Gravity_PANGO2_GRAVITY_AUTO: Pango2Gravity = 4;
#[doc = " Pango2Gravity:\n @PANGO2_GRAVITY_SOUTH: Glyphs stand upright (default) <img align=\"right\" valign=\"center\" src=\"m-south.png\">\n @PANGO2_GRAVITY_EAST: Glyphs are rotated 90 degrees counter-clockwise. <img align=\"right\" valign=\"center\" src=\"m-east.png\">\n @PANGO2_GRAVITY_NORTH: Glyphs are upside-down. <img align=\"right\" valign=\"cener\" src=\"m-north.png\">\n @PANGO2_GRAVITY_WEST: Glyphs are rotated 90 degrees clockwise. <img align=\"right\" valign=\"center\" src=\"m-west.png\">\n @PANGO2_GRAVITY_AUTO: Gravity is resolved from the context matrix\n\n `Pango2Gravity` represents the orientation of glyphs in a segment\n of text.\n\n This is useful when rendering vertical text layouts. In those situations,\n the layout is rotated using a non-identity [struct@Pango2.Matrix], and then\n glyph orientation is controlled using `Pango2Gravity`.\n\n Not every value in this enumeration makes sense for every usage of\n `Pango2Gravity`; for example, %PANGO2_GRAVITY_AUTO only can be passed to\n [method@Pango2.Context.set_base_gravity] and can only be returned by\n [method@Pango2.Context.get_base_gravity].\n\n See also: [enum@Pango2.GravityHint]"]
pub type Pango2Gravity = ::std::os::raw::c_uint;
pub const Pango2GravityHint_PANGO2_GRAVITY_HINT_NATURAL: Pango2GravityHint = 0;
pub const Pango2GravityHint_PANGO2_GRAVITY_HINT_STRONG: Pango2GravityHint = 1;
pub const Pango2GravityHint_PANGO2_GRAVITY_HINT_LINE: Pango2GravityHint = 2;
#[doc = " Pango2GravityHint:\n @PANGO2_GRAVITY_HINT_NATURAL: scripts will take their natural gravity based\n   on the base gravity and the script.  This is the default.\n @PANGO2_GRAVITY_HINT_STRONG: always use the base gravity set, regardless of\n   the script.\n @PANGO2_GRAVITY_HINT_LINE: for scripts not in their natural direction (eg.\n   Latin in East gravity), choose per-script gravity such that every script\n   respects the line progression. This means, Latin and Arabic will take\n   opposite gravities and both flow top-to-bottom for example.\n\n `Pango2GravityHint` defines how horizontal scripts should behave in a\n vertical context.\n\n That is, English excerpts in a vertical paragraph for example.\n\n See also [enum@Pango2.Gravity]"]
pub type Pango2GravityHint = ::std::os::raw::c_uint;
#[doc = " Pango2Matrix:\n @xx: 1st component of the transformation matrix\n @xy: 2nd component of the transformation matrix\n @yx: 3rd component of the transformation matrix\n @yy: 4th component of the transformation matrix\n @x0: x translation\n @y0: y translation\n\n A `Pango2Matrix` specifies a transformation between user-space\n and device coordinates.\n\n The transformation is given by\n\n ```\n x_device = x_user * matrix->xx + y_user * matrix->xy + matrix->x0;\n y_device = x_user * matrix->yx + y_user * matrix->yy + matrix->y0;\n ```"]
pub type Pango2Matrix = _Pango2Matrix;
#[doc = " Pango2Matrix:\n @xx: 1st component of the transformation matrix\n @xy: 2nd component of the transformation matrix\n @yx: 3rd component of the transformation matrix\n @yy: 4th component of the transformation matrix\n @x0: x translation\n @y0: y translation\n\n A `Pango2Matrix` specifies a transformation between user-space\n and device coordinates.\n\n The transformation is given by\n\n ```\n x_device = x_user * matrix->xx + y_user * matrix->xy + matrix->x0;\n y_device = x_user * matrix->yx + y_user * matrix->yy + matrix->y0;\n ```"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2Matrix {
    pub xx: f64,
    pub xy: f64,
    pub yx: f64,
    pub yy: f64,
    pub x0: f64,
    pub y0: f64,
}
#[test]
fn bindgen_test_layout__Pango2Matrix() {
    const UNINIT: ::std::mem::MaybeUninit<_Pango2Matrix> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Pango2Matrix>(),
        48usize,
        concat!("Size of: ", stringify!(_Pango2Matrix))
    );
    assert_eq!(
        ::std::mem::align_of::<_Pango2Matrix>(),
        8usize,
        concat!("Alignment of ", stringify!(_Pango2Matrix))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2Matrix),
            "::",
            stringify!(xx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2Matrix),
            "::",
            stringify!(xy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2Matrix),
            "::",
            stringify!(yx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2Matrix),
            "::",
            stringify!(yy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x0) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2Matrix),
            "::",
            stringify!(x0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y0) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2Matrix),
            "::",
            stringify!(y0)
        )
    );
}
extern "C" {
    pub fn pango2_matrix_get_type() -> GType;
}
extern "C" {
    pub fn pango2_matrix_copy(matrix: *const Pango2Matrix) -> *mut Pango2Matrix;
}
extern "C" {
    pub fn pango2_matrix_free(matrix: *mut Pango2Matrix);
}
extern "C" {
    pub fn pango2_matrix_equal(m1: *const Pango2Matrix, m2: *const Pango2Matrix) -> gboolean;
}
extern "C" {
    pub fn pango2_matrix_translate(matrix: *mut Pango2Matrix, tx: f64, ty: f64);
}
extern "C" {
    pub fn pango2_matrix_scale(matrix: *mut Pango2Matrix, scale_x: f64, scale_y: f64);
}
extern "C" {
    pub fn pango2_matrix_rotate(matrix: *mut Pango2Matrix, degrees: f64);
}
extern "C" {
    pub fn pango2_matrix_concat(matrix: *mut Pango2Matrix, new_matrix: *const Pango2Matrix);
}
extern "C" {
    pub fn pango2_matrix_transform_point(matrix: *const Pango2Matrix, x: *mut f64, y: *mut f64);
}
extern "C" {
    pub fn pango2_matrix_transform_distance(
        matrix: *const Pango2Matrix,
        dx: *mut f64,
        dy: *mut f64,
    );
}
extern "C" {
    pub fn pango2_matrix_transform_rectangle(
        matrix: *const Pango2Matrix,
        rect: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_matrix_transform_pixel_rectangle(
        matrix: *const Pango2Matrix,
        rect: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_matrix_get_font_scale_factor(matrix: *const Pango2Matrix) -> f64;
}
extern "C" {
    pub fn pango2_matrix_get_font_scale_factors(
        matrix: *const Pango2Matrix,
        xscale: *mut f64,
        yscale: *mut f64,
    );
}
extern "C" {
    pub fn pango2_matrix_get_rotation(matrix: *const Pango2Matrix) -> f64;
}
extern "C" {
    pub fn pango2_matrix_get_slant_ratio(matrix: *const Pango2Matrix) -> f64;
}
extern "C" {
    pub fn pango2_language_get_type() -> GType;
}
extern "C" {
    pub fn pango2_language_get_default() -> *mut Pango2Language;
}
extern "C" {
    pub fn pango2_language_get_preferred() -> *mut *mut Pango2Language;
}
extern "C" {
    pub fn pango2_language_from_string(
        language: *const ::std::os::raw::c_char,
    ) -> *mut Pango2Language;
}
extern "C" {
    pub fn pango2_language_to_string(
        language: *mut Pango2Language,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pango2_language_get_sample_string(
        language: *mut Pango2Language,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pango2_language_matches(
        language: *mut Pango2Language,
        range_list: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn pango2_language_includes_script(
        language: *mut Pango2Language,
        script: GUnicodeScript,
    ) -> gboolean;
}
extern "C" {
    pub fn pango2_language_get_scripts(
        language: *mut Pango2Language,
        num_scripts: *mut ::std::os::raw::c_int,
    ) -> *const GUnicodeScript;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2ScriptIter {
    _unused: [u8; 0],
}
#[doc = " Pango2ScriptIter:\n\n A `Pango2ScriptIter` is used to iterate through a string\n and identify ranges in different scripts."]
pub type Pango2ScriptIter = _Pango2ScriptIter;
extern "C" {
    pub fn pango2_script_iter_get_type() -> GType;
}
extern "C" {
    pub fn pango2_script_iter_new(
        text: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    ) -> *mut Pango2ScriptIter;
}
extern "C" {
    pub fn pango2_script_iter_get_range(
        iter: *mut Pango2ScriptIter,
        start: *mut *const ::std::os::raw::c_char,
        end: *mut *const ::std::os::raw::c_char,
        script: *mut GUnicodeScript,
    );
}
extern "C" {
    pub fn pango2_script_iter_next(iter: *mut Pango2ScriptIter) -> gboolean;
}
extern "C" {
    pub fn pango2_script_iter_free(iter: *mut Pango2ScriptIter);
}
extern "C" {
    pub fn pango2_script_get_sample_language(script: GUnicodeScript) -> *mut Pango2Language;
}
extern "C" {
    pub fn pango2_gravity_to_rotation(gravity: Pango2Gravity) -> f64;
}
extern "C" {
    pub fn pango2_gravity_get_for_matrix(matrix: *const Pango2Matrix) -> Pango2Gravity;
}
extern "C" {
    pub fn pango2_gravity_get_for_script(
        script: GUnicodeScript,
        base_gravity: Pango2Gravity,
        hint: Pango2GravityHint,
    ) -> Pango2Gravity;
}
extern "C" {
    pub fn pango2_gravity_get_for_script_and_width(
        script: GUnicodeScript,
        wide: gboolean,
        base_gravity: Pango2Gravity,
        hint: Pango2GravityHint,
    ) -> Pango2Gravity;
}
pub const Pango2Alignment_PANGO2_ALIGN_LEFT: Pango2Alignment = 0;
pub const Pango2Alignment_PANGO2_ALIGN_CENTER: Pango2Alignment = 1;
pub const Pango2Alignment_PANGO2_ALIGN_RIGHT: Pango2Alignment = 2;
pub const Pango2Alignment_PANGO2_ALIGN_NATURAL: Pango2Alignment = 3;
pub const Pango2Alignment_PANGO2_ALIGN_JUSTIFY: Pango2Alignment = 4;
#[doc = " Pango2Alignment:\n @PANGO2_ALIGN_LEFT: Put all available space on the right\n @PANGO2_ALIGN_CENTER: Center the line within the available space\n @PANGO2_ALIGN_RIGHT: Put all available space on the left\n @PANGO2_ALIGN_NATURAL: Use left or right alignment, depending\n   on the text direction of the paragraph\n @PANGO2_ALIGN_JUSTIFY: Justify the content to fill the available space\n\n `Pango2Alignment` describes how to align the lines of a `Pango2Layout`\n within the available space."]
pub type Pango2Alignment = ::std::os::raw::c_uint;
pub const Pango2WrapMode_PANGO2_WRAP_WORD: Pango2WrapMode = 0;
pub const Pango2WrapMode_PANGO2_WRAP_CHAR: Pango2WrapMode = 1;
pub const Pango2WrapMode_PANGO2_WRAP_WORD_CHAR: Pango2WrapMode = 2;
#[doc = " Pango2WrapMode:\n @PANGO2_WRAP_WORD: wrap lines at word boundaries.\n @PANGO2_WRAP_CHAR: wrap lines at character boundaries.\n @PANGO2_WRAP_WORD_CHAR: wrap lines at word boundaries, but fall back to\n   character boundaries if there is not enough space for a full word.\n\n `Pango2WrapMode` describes how to wrap the lines of a `Pango2Layout`\n to the desired width.\n\n For @PANGO2_WRAP_WORD, Pango uses break opportunities that are determined\n by the Unicode line breaking algorithm. For @PANGO2_WRAP_CHAR, Pango allows\n breaking at grapheme boundaries that are determined by the Unicode text\n segmentation algorithm."]
pub type Pango2WrapMode = ::std::os::raw::c_uint;
pub const Pango2EllipsizeMode_PANGO2_ELLIPSIZE_NONE: Pango2EllipsizeMode = 0;
pub const Pango2EllipsizeMode_PANGO2_ELLIPSIZE_START: Pango2EllipsizeMode = 1;
pub const Pango2EllipsizeMode_PANGO2_ELLIPSIZE_MIDDLE: Pango2EllipsizeMode = 2;
pub const Pango2EllipsizeMode_PANGO2_ELLIPSIZE_END: Pango2EllipsizeMode = 3;
#[doc = " Pango2EllipsizeMode:\n @PANGO2_ELLIPSIZE_NONE: No ellipsization\n @PANGO2_ELLIPSIZE_START: Omit characters at the start of the text\n @PANGO2_ELLIPSIZE_MIDDLE: Omit characters in the middle of the text\n @PANGO2_ELLIPSIZE_END: Omit characters at the end of the text\n\n `Pango2EllipsizeMode` describes what sort of ellipsization\n should be applied to text.\n\n In the ellipsization process characters are removed from the\n text in order to make it fit to a given width and replaced\n with an ellipsis."]
pub type Pango2EllipsizeMode = ::std::os::raw::c_uint;
pub const Pango2LeadingTrim_PANGO2_LEADING_TRIM_NONE: Pango2LeadingTrim = 0;
pub const Pango2LeadingTrim_PANGO2_LEADING_TRIM_START: Pango2LeadingTrim = 1;
pub const Pango2LeadingTrim_PANGO2_LEADING_TRIM_END: Pango2LeadingTrim = 2;
#[doc = " Pango2LeadingTrim:\n @PANGO2_LEADING_TRIM_NONE: No trimming\n @PANGO2_LEADING_TRIM_START: Trim leading at the top\n @PANGO2_LEADING_TRIM_END: Trim leading at the bottom\n\n The `Pango2LeadingTrim` flags control how the line height affects\n the extents of runs and lines."]
pub type Pango2LeadingTrim = ::std::os::raw::c_uint;
pub const Pango2EmojiPresentation_PANGO2_EMOJI_PRESENTATION_AUTO: Pango2EmojiPresentation = 0;
pub const Pango2EmojiPresentation_PANGO2_EMOJI_PRESENTATION_TEXT: Pango2EmojiPresentation = 1;
pub const Pango2EmojiPresentation_PANGO2_EMOJI_PRESENTATION_EMOJI: Pango2EmojiPresentation = 2;
#[doc = " Pango2EmojiPresentation:\n @PANGO2_EMOJI_PRESENTATION_AUTO: Present Emoji with to their\n   default presentation according to Unicode\n @PANGO2_EMOJI_PRESENTATION_TEXT: Prefer text presentation\n @PANGO2_EMOJI_PRESENTATION_EMOJI: Prefer Emoji presentation\n\n `Pango2EmojiPresentation` describes a preference for Emoji\n presentation style.\n\n See [method@Pango2.Context.set_emoji_presentation] or\n [func@Pango2.attr_emoji_presentation_new] for ways to communicate\n Emoji presentation style preferences to Pango.\n\n Note that even with such a preference, Pango will respect\n Emoji presentation style if it has been explicitly selected\n with a Unicode [variation selector](https://unicode.org/reports/tr51/#Emoji_Variation_Sequences)."]
pub type Pango2EmojiPresentation = ::std::os::raw::c_uint;
pub const Pango2Style_PANGO2_STYLE_NORMAL: Pango2Style = 0;
pub const Pango2Style_PANGO2_STYLE_OBLIQUE: Pango2Style = 1;
pub const Pango2Style_PANGO2_STYLE_ITALIC: Pango2Style = 2;
#[doc = " Pango2Style:\n @PANGO2_STYLE_NORMAL: the font is upright.\n @PANGO2_STYLE_OBLIQUE: the font is slanted, but in a roman style.\n @PANGO2_STYLE_ITALIC: the font is slanted in an italic style.\n\n An enumeration specifying the various slant styles possible for a font."]
pub type Pango2Style = ::std::os::raw::c_uint;
pub const Pango2Variant_PANGO2_VARIANT_NORMAL: Pango2Variant = 0;
pub const Pango2Variant_PANGO2_VARIANT_SMALL_CAPS: Pango2Variant = 1;
pub const Pango2Variant_PANGO2_VARIANT_ALL_SMALL_CAPS: Pango2Variant = 2;
pub const Pango2Variant_PANGO2_VARIANT_PETITE_CAPS: Pango2Variant = 3;
pub const Pango2Variant_PANGO2_VARIANT_ALL_PETITE_CAPS: Pango2Variant = 4;
pub const Pango2Variant_PANGO2_VARIANT_UNICASE: Pango2Variant = 5;
pub const Pango2Variant_PANGO2_VARIANT_TITLE_CAPS: Pango2Variant = 6;
#[doc = " Pango2Variant:\n @PANGO2_VARIANT_NORMAL: A normal font.\n @PANGO2_VARIANT_SMALL_CAPS: A font with the lower case characters\n   replaced by smaller variants of the capital characters.\n @PANGO2_VARIANT_ALL_SMALL_CAPS: A font with all characters\n   replaced by smaller variants of the capital characters.\n @PANGO2_VARIANT_PETITE_CAPS: A font with the lower case characters\n   replaced by smaller variants of the capital characters.\n   Petite Caps can be even smaller than Small Caps.\n @PANGO2_VARIANT_ALL_PETITE_CAPS: A font with all characters\n   replaced by smaller variants of the capital characters.\n   Petite Caps can be even smaller than Small Caps.\n @PANGO2_VARIANT_UNICASE: A font with the upper case characters\n   replaced by smaller variants of the capital letters.\n @PANGO2_VARIANT_TITLE_CAPS: A font with capital letters that\n   are more suitable for all-uppercase titles.\n\n An enumeration specifying capitalization variant of the font."]
pub type Pango2Variant = ::std::os::raw::c_uint;
pub const Pango2Weight_PANGO2_WEIGHT_THIN: Pango2Weight = 100;
pub const Pango2Weight_PANGO2_WEIGHT_ULTRALIGHT: Pango2Weight = 200;
pub const Pango2Weight_PANGO2_WEIGHT_LIGHT: Pango2Weight = 300;
pub const Pango2Weight_PANGO2_WEIGHT_SEMILIGHT: Pango2Weight = 350;
pub const Pango2Weight_PANGO2_WEIGHT_BOOK: Pango2Weight = 380;
pub const Pango2Weight_PANGO2_WEIGHT_NORMAL: Pango2Weight = 400;
pub const Pango2Weight_PANGO2_WEIGHT_MEDIUM: Pango2Weight = 500;
pub const Pango2Weight_PANGO2_WEIGHT_SEMIBOLD: Pango2Weight = 600;
pub const Pango2Weight_PANGO2_WEIGHT_BOLD: Pango2Weight = 700;
pub const Pango2Weight_PANGO2_WEIGHT_ULTRABOLD: Pango2Weight = 800;
pub const Pango2Weight_PANGO2_WEIGHT_HEAVY: Pango2Weight = 900;
pub const Pango2Weight_PANGO2_WEIGHT_ULTRAHEAVY: Pango2Weight = 1000;
#[doc = " Pango2Weight:\n @PANGO2_WEIGHT_THIN: the thin weight (= 100)\n @PANGO2_WEIGHT_ULTRALIGHT: the ultralight weight (= 200)\n @PANGO2_WEIGHT_LIGHT: the light weight (= 300)\n @PANGO2_WEIGHT_SEMILIGHT: the semilight weight (= 350)\n @PANGO2_WEIGHT_BOOK: the book weight (= 380)\n @PANGO2_WEIGHT_NORMAL: the default weight (= 400)\n @PANGO2_WEIGHT_MEDIUM: the normal weight (= 500)\n @PANGO2_WEIGHT_SEMIBOLD: the semibold weight (= 600)\n @PANGO2_WEIGHT_BOLD: the bold weight (= 700)\n @PANGO2_WEIGHT_ULTRABOLD: the ultrabold weight (= 800)\n @PANGO2_WEIGHT_HEAVY: the heavy weight (= 900)\n @PANGO2_WEIGHT_ULTRAHEAVY: the ultraheavy weight (= 1000)\n\n A `Pango2Weight` specifes the weight (boldness) of a font.\n\n Weight is specified as a numeric value ranging from 100 to 1000.\n This enumeration simply provides some common, predefined values."]
pub type Pango2Weight = ::std::os::raw::c_uint;
pub const Pango2Stretch_PANGO2_STRETCH_ULTRA_CONDENSED: Pango2Stretch = 500;
pub const Pango2Stretch_PANGO2_STRETCH_EXTRA_CONDENSED: Pango2Stretch = 625;
pub const Pango2Stretch_PANGO2_STRETCH_CONDENSED: Pango2Stretch = 750;
pub const Pango2Stretch_PANGO2_STRETCH_SEMI_CONDENSED: Pango2Stretch = 875;
pub const Pango2Stretch_PANGO2_STRETCH_NORMAL: Pango2Stretch = 1000;
pub const Pango2Stretch_PANGO2_STRETCH_SEMI_EXPANDED: Pango2Stretch = 1125;
pub const Pango2Stretch_PANGO2_STRETCH_EXPANDED: Pango2Stretch = 1250;
pub const Pango2Stretch_PANGO2_STRETCH_EXTRA_EXPANDED: Pango2Stretch = 1500;
pub const Pango2Stretch_PANGO2_STRETCH_ULTRA_EXPANDED: Pango2Stretch = 2000;
#[doc = " Pango2Stretch:\n @PANGO2_STRETCH_ULTRA_CONDENSED: ultra-condensed width (= 500)\n @PANGO2_STRETCH_EXTRA_CONDENSED: extra-condensed width (= 625)\n @PANGO2_STRETCH_CONDENSED: condensed width (= 750)\n @PANGO2_STRETCH_SEMI_CONDENSED: semi-condensed width (= 875)\n @PANGO2_STRETCH_NORMAL: the normal width (= 1000)\n @PANGO2_STRETCH_SEMI_EXPANDED: semi-expanded width (= 1125)\n @PANGO2_STRETCH_EXPANDED: expanded width (= 1250)\n @PANGO2_STRETCH_EXTRA_EXPANDED: extra-expanded width (= 1500)\n @PANGO2_STRETCH_ULTRA_EXPANDED: ultra-expanded width (= 2000)\n\n A `Pango2Stretch` specifes the width of the font relative\n to other designs within a family.\n\n Stretch is specified as a numeric value ranging from 500 to 2000.\n This enumeration simply provides some common, predefined values."]
pub type Pango2Stretch = ::std::os::raw::c_uint;
pub const Pango2FontMask_PANGO2_FONT_MASK_FAMILY: Pango2FontMask = 1;
pub const Pango2FontMask_PANGO2_FONT_MASK_STYLE: Pango2FontMask = 2;
pub const Pango2FontMask_PANGO2_FONT_MASK_VARIANT: Pango2FontMask = 4;
pub const Pango2FontMask_PANGO2_FONT_MASK_WEIGHT: Pango2FontMask = 8;
pub const Pango2FontMask_PANGO2_FONT_MASK_STRETCH: Pango2FontMask = 16;
pub const Pango2FontMask_PANGO2_FONT_MASK_SIZE: Pango2FontMask = 32;
pub const Pango2FontMask_PANGO2_FONT_MASK_GRAVITY: Pango2FontMask = 64;
pub const Pango2FontMask_PANGO2_FONT_MASK_VARIATIONS: Pango2FontMask = 128;
pub const Pango2FontMask_PANGO2_FONT_MASK_FACEID: Pango2FontMask = 256;
#[doc = " Pango2FontMask:\n @PANGO2_FONT_MASK_FAMILY: the font family is specified.\n @PANGO2_FONT_MASK_STYLE: the font style is specified.\n @PANGO2_FONT_MASK_VARIANT: the font variant is specified.\n @PANGO2_FONT_MASK_WEIGHT: the font weight is specified.\n @PANGO2_FONT_MASK_STRETCH: the font stretch is specified.\n @PANGO2_FONT_MASK_SIZE: the font size is specified.\n @PANGO2_FONT_MASK_GRAVITY: the font gravity is specified\n @PANGO2_FONT_MASK_VARIATIONS: OpenType font variations are specified\n @PANGO2_FONT_MASK_FACEID: the face ID is specified\n\n The bits in a `Pango2FontMask` correspond to the set fields in a\n `Pango2FontDescription`."]
pub type Pango2FontMask = ::std::os::raw::c_uint;
extern "C" {
    pub fn pango2_font_description_get_type() -> GType;
}
extern "C" {
    pub fn pango2_font_description_new() -> *mut Pango2FontDescription;
}
extern "C" {
    pub fn pango2_font_description_copy(
        desc: *const Pango2FontDescription,
    ) -> *mut Pango2FontDescription;
}
extern "C" {
    pub fn pango2_font_description_copy_static(
        desc: *const Pango2FontDescription,
    ) -> *mut Pango2FontDescription;
}
extern "C" {
    pub fn pango2_font_description_hash(desc: *const Pango2FontDescription) -> guint;
}
extern "C" {
    pub fn pango2_font_description_equal(
        desc1: *const Pango2FontDescription,
        desc2: *const Pango2FontDescription,
    ) -> gboolean;
}
extern "C" {
    pub fn pango2_font_description_free(desc: *mut Pango2FontDescription);
}
extern "C" {
    pub fn pango2_font_description_set_family(
        desc: *mut Pango2FontDescription,
        family: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pango2_font_description_set_family_static(
        desc: *mut Pango2FontDescription,
        family: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pango2_font_description_get_family(
        desc: *const Pango2FontDescription,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pango2_font_description_set_style(desc: *mut Pango2FontDescription, style: Pango2Style);
}
extern "C" {
    pub fn pango2_font_description_get_style(desc: *const Pango2FontDescription) -> Pango2Style;
}
extern "C" {
    pub fn pango2_font_description_set_variant(
        desc: *mut Pango2FontDescription,
        variant: Pango2Variant,
    );
}
extern "C" {
    pub fn pango2_font_description_get_variant(desc: *const Pango2FontDescription)
        -> Pango2Variant;
}
extern "C" {
    pub fn pango2_font_description_set_weight(
        desc: *mut Pango2FontDescription,
        weight: Pango2Weight,
    );
}
extern "C" {
    pub fn pango2_font_description_get_weight(desc: *const Pango2FontDescription) -> Pango2Weight;
}
extern "C" {
    pub fn pango2_font_description_set_stretch(
        desc: *mut Pango2FontDescription,
        stretch: Pango2Stretch,
    );
}
extern "C" {
    pub fn pango2_font_description_get_stretch(desc: *const Pango2FontDescription)
        -> Pango2Stretch;
}
extern "C" {
    pub fn pango2_font_description_set_size(
        desc: *mut Pango2FontDescription,
        size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_font_description_get_size(
        desc: *const Pango2FontDescription,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_font_description_set_absolute_size(desc: *mut Pango2FontDescription, size: f64);
}
extern "C" {
    pub fn pango2_font_description_get_size_is_absolute(
        desc: *const Pango2FontDescription,
    ) -> gboolean;
}
extern "C" {
    pub fn pango2_font_description_set_gravity(
        desc: *mut Pango2FontDescription,
        gravity: Pango2Gravity,
    );
}
extern "C" {
    pub fn pango2_font_description_get_gravity(desc: *const Pango2FontDescription)
        -> Pango2Gravity;
}
extern "C" {
    pub fn pango2_font_description_set_variations_static(
        desc: *mut Pango2FontDescription,
        variations: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pango2_font_description_set_variations(
        desc: *mut Pango2FontDescription,
        variations: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pango2_font_description_get_variations(
        desc: *const Pango2FontDescription,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pango2_font_description_set_faceid(
        desc: *mut Pango2FontDescription,
        faceid: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pango2_font_description_set_faceid_static(
        desc: *mut Pango2FontDescription,
        faceid: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pango2_font_description_get_faceid(
        desc: *const Pango2FontDescription,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pango2_font_description_get_set_fields(
        desc: *const Pango2FontDescription,
    ) -> Pango2FontMask;
}
extern "C" {
    pub fn pango2_font_description_unset_fields(
        desc: *mut Pango2FontDescription,
        to_unset: Pango2FontMask,
    );
}
extern "C" {
    pub fn pango2_font_description_merge(
        desc: *mut Pango2FontDescription,
        desc_to_merge: *const Pango2FontDescription,
        replace_existing: gboolean,
    );
}
extern "C" {
    pub fn pango2_font_description_merge_static(
        desc: *mut Pango2FontDescription,
        desc_to_merge: *const Pango2FontDescription,
        replace_existing: gboolean,
    );
}
extern "C" {
    pub fn pango2_font_description_from_string(
        str_: *const ::std::os::raw::c_char,
    ) -> *mut Pango2FontDescription;
}
extern "C" {
    pub fn pango2_font_description_to_string(
        desc: *const Pango2FontDescription,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2FontMetrics {
    _unused: [u8; 0],
}
#[doc = " Pango2FontMetrics:\n\n A `Pango2FontMetrics` structure holds the overall metric information\n for a font.\n\n The information in a `Pango2FontMetrics` structure may be restricted\n to a script. The fields of this structure are private to implementations\n of a font backend. See the documentation of the corresponding getters\n for documentation of their meaning.\n\n For an overview of the most important metrics, see:\n\n <picture>\n   <source srcset=\"fontmetrics-dark.png\" media=\"(prefers-color-scheme: dark)\">\n   <img alt=\"Font metrics\" src=\"fontmetrics-light.png\">\n </picture>\n"]
pub type Pango2FontMetrics = _Pango2FontMetrics;
extern "C" {
    pub fn pango2_font_metrics_get_type() -> GType;
}
extern "C" {
    pub fn pango2_font_metrics_copy(metrics: *mut Pango2FontMetrics) -> *mut Pango2FontMetrics;
}
extern "C" {
    pub fn pango2_font_metrics_free(metrics: *mut Pango2FontMetrics);
}
extern "C" {
    pub fn pango2_font_metrics_get_ascent(metrics: *mut Pango2FontMetrics)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_font_metrics_get_descent(
        metrics: *mut Pango2FontMetrics,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_font_metrics_get_height(metrics: *mut Pango2FontMetrics)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_font_metrics_get_approximate_char_width(
        metrics: *mut Pango2FontMetrics,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_font_metrics_get_approximate_digit_width(
        metrics: *mut Pango2FontMetrics,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_font_metrics_get_underline_position(
        metrics: *mut Pango2FontMetrics,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_font_metrics_get_underline_thickness(
        metrics: *mut Pango2FontMetrics,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_font_metrics_get_strikethrough_position(
        metrics: *mut Pango2FontMetrics,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_font_metrics_get_strikethrough_thickness(
        metrics: *mut Pango2FontMetrics,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_font_family_get_type() -> GType;
}
extern "C" {
    pub fn pango2_font_family_get_font_map(family: *mut Pango2FontFamily) -> *mut Pango2FontMap;
}
extern "C" {
    pub fn pango2_font_family_get_name(
        family: *mut Pango2FontFamily,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pango2_font_family_get_face(
        family: *mut Pango2FontFamily,
        name: *const ::std::os::raw::c_char,
    ) -> *mut Pango2FontFace;
}
extern "C" {
    pub fn pango2_font_get_type() -> GType;
}
extern "C" {
    pub fn pango2_font_describe(font: *mut Pango2Font) -> *mut Pango2FontDescription;
}
extern "C" {
    pub fn pango2_font_describe_with_absolute_size(
        font: *mut Pango2Font,
    ) -> *mut Pango2FontDescription;
}
extern "C" {
    pub fn pango2_font_get_metrics(
        font: *mut Pango2Font,
        language: *mut Pango2Language,
    ) -> *mut Pango2FontMetrics;
}
extern "C" {
    pub fn pango2_font_get_glyph_extents(
        font: *mut Pango2Font,
        glyph: Pango2Glyph,
        ink_rect: *mut Pango2Rectangle,
        logical_rect: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_font_get_face(font: *mut Pango2Font) -> *mut Pango2FontFace;
}
extern "C" {
    pub fn pango2_font_get_hb_font(font: *mut Pango2Font) -> *mut hb_font_t;
}
extern "C" {
    pub fn pango2_font_get_size(font: *mut Pango2Font) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_font_get_absolute_size(font: *mut Pango2Font) -> f64;
}
extern "C" {
    pub fn pango2_font_get_gravity(font: *mut Pango2Font) -> Pango2Gravity;
}
extern "C" {
    pub fn pango2_font_serialize(font: *mut Pango2Font) -> *mut GBytes;
}
extern "C" {
    pub fn pango2_font_deserialize(
        context: *mut Pango2Context,
        bytes: *mut GBytes,
        error: *mut *mut GError,
    ) -> *mut Pango2Font;
}
#[doc = " Pango2Color:\n @red: value of the red component\n @green: value of the green component\n @blue: value of the blue component\n @alpha: value of the alpha component\n\n The `Pango2Color` structure is used to\n represent a color in an uncalibrated RGB color-space."]
pub type Pango2Color = _Pango2Color;
#[doc = " Pango2Color:\n @red: value of the red component\n @green: value of the green component\n @blue: value of the blue component\n @alpha: value of the alpha component\n\n The `Pango2Color` structure is used to\n represent a color in an uncalibrated RGB color-space."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2Color {
    pub red: guint16,
    pub green: guint16,
    pub blue: guint16,
    pub alpha: guint16,
}
#[test]
fn bindgen_test_layout__Pango2Color() {
    const UNINIT: ::std::mem::MaybeUninit<_Pango2Color> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Pango2Color>(),
        8usize,
        concat!("Size of: ", stringify!(_Pango2Color))
    );
    assert_eq!(
        ::std::mem::align_of::<_Pango2Color>(),
        2usize,
        concat!("Alignment of ", stringify!(_Pango2Color))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2Color),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2Color),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2Color),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2Color),
            "::",
            stringify!(alpha)
        )
    );
}
extern "C" {
    pub fn pango2_color_get_type() -> GType;
}
extern "C" {
    pub fn pango2_color_copy(src: *const Pango2Color) -> *mut Pango2Color;
}
extern "C" {
    pub fn pango2_color_free(color: *mut Pango2Color);
}
extern "C" {
    pub fn pango2_color_equal(color1: *const Pango2Color, color2: *const Pango2Color) -> gboolean;
}
extern "C" {
    pub fn pango2_color_parse(
        color: *mut Pango2Color,
        spec: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn pango2_color_to_string(color: *const Pango2Color) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2Attribute {
    _unused: [u8; 0],
}
pub type Pango2Attribute = _Pango2Attribute;
pub const Pango2AttrValueType_PANGO2_ATTR_VALUE_STRING: Pango2AttrValueType = 0;
pub const Pango2AttrValueType_PANGO2_ATTR_VALUE_INT: Pango2AttrValueType = 1;
pub const Pango2AttrValueType_PANGO2_ATTR_VALUE_BOOLEAN: Pango2AttrValueType = 2;
pub const Pango2AttrValueType_PANGO2_ATTR_VALUE_FLOAT: Pango2AttrValueType = 3;
pub const Pango2AttrValueType_PANGO2_ATTR_VALUE_COLOR: Pango2AttrValueType = 4;
pub const Pango2AttrValueType_PANGO2_ATTR_VALUE_LANGUAGE: Pango2AttrValueType = 5;
pub const Pango2AttrValueType_PANGO2_ATTR_VALUE_FONT_DESC: Pango2AttrValueType = 6;
pub const Pango2AttrValueType_PANGO2_ATTR_VALUE_POINTER: Pango2AttrValueType = 7;
#[doc = " Pango2AttrValueType:\n @PANGO2_ATTR_VALUE_STRING: A string\n @PANGO2_ATTR_VALUE_INT: An integer\n @PANGO2_ATTR_VALUE_BOOLEAN: A boolean\n @PANGO2_ATTR_VALUE_FLOAT: A floating point number\n @PANGO2_ATTR_VALUE_COLOR: A `Pango2Color`\n @PANGO2_ATTR_VALUE_LANGUAGE: A `Pango2Language`\n @PANGO2_ATTR_VALUE_FONT_DESC: A `Pango2FontDescription`\n @PANGO2_ATTR_VALUE_POINTER: A generic pointer\n\n `Pango2AttrValueType` enumerates the types of values\n that a `Pango2Attribute` can contain.\n\n The `Pango2AttrValueType` of a `Pango2Attribute` is part\n of its type, and can be obtained with `PANGO2_ATTR_VALUE_TYPE()`."]
pub type Pango2AttrValueType = ::std::os::raw::c_uint;
pub const Pango2AttrAffects_PANGO2_ATTR_AFFECTS_NONE: Pango2AttrAffects = 0;
pub const Pango2AttrAffects_PANGO2_ATTR_AFFECTS_ITEMIZATION: Pango2AttrAffects = 1;
pub const Pango2AttrAffects_PANGO2_ATTR_AFFECTS_BREAKING: Pango2AttrAffects = 2;
pub const Pango2AttrAffects_PANGO2_ATTR_AFFECTS_SHAPING: Pango2AttrAffects = 4;
pub const Pango2AttrAffects_PANGO2_ATTR_AFFECTS_RENDERING: Pango2AttrAffects = 8;
#[doc = " Pango2AttrAffects:\n @PANGO2_ATTR_AFFECTS_NONE: The attribute does not affect rendering\n @PANGO2_ATTR_AFFECTS_ITEMIZATION: The attribute affecs itemization\n @PANGO2_ATTR_AFFECTS_BREAKING: The attribute affects `Pango2LogAttr` determination\n @PANGO2_ATTR_AFFECTS_SHAPING: The attribute affects shaping\n @PANGO2_ATTR_AFFECTS_RENDERING: The attribute affects rendering\n\n A `Pango2AttrAffects` value indicates what part of Pango2's processing\n pipeline is affected by an attribute.\n\n Marking an attribute with `PANGO2_ATTR_AFFECTS_ITEMIZATION` ensures\n that the attribute values are constant across items."]
pub type Pango2AttrAffects = ::std::os::raw::c_uint;
pub const Pango2AttrMerge_PANGO2_ATTR_MERGE_OVERRIDES: Pango2AttrMerge = 0;
pub const Pango2AttrMerge_PANGO2_ATTR_MERGE_ACCUMULATES: Pango2AttrMerge = 1;
#[doc = " Pango2AttrMerge:\n @PANGO2_ATTR_MERGE_OVERRIDES: Only the attribute with the narrowest range is used\n @PANGO2_ATTR_MERGE_ACCUMULATES: All attributes with overlapping range are kept\n\n A `Pango2AttrMerge` value indicates how overlapping attribute values\n should be reconciled to determine the effective attribute value.\n\n These options influence the @extra_attrs returned by\n [method@Pango2.AttrIterator.get_font]."]
pub type Pango2AttrMerge = ::std::os::raw::c_uint;
#[doc = " Pango2AttrDataCopyFunc:\n @value: value to copy\n\n Callback to duplicate the value of an attribute.\n\n Return value: new copy of @value."]
pub type Pango2AttrDataCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(value: gconstpointer) -> gpointer>;
#[doc = " Pango2AttrDataSerializeFunc:\n @value: value to serialize\n\n Callback to serialize the value of an attribute.\n\n Return value: a newly allocated string holding the serialization of @value"]
pub type Pango2AttrDataSerializeFunc = ::std::option::Option<
    unsafe extern "C" fn(value: gconstpointer) -> *mut ::std::os::raw::c_char,
>;
extern "C" {
    pub fn pango2_attribute_get_type() -> GType;
}
extern "C" {
    pub fn pango2_attr_type_register(
        name: *const ::std::os::raw::c_char,
        value_type: Pango2AttrValueType,
        affects: Pango2AttrAffects,
        merge: Pango2AttrMerge,
        copy: Pango2AttrDataCopyFunc,
        destroy: GDestroyNotify,
        equal: GEqualFunc,
        serialize: Pango2AttrDataSerializeFunc,
    ) -> guint;
}
extern "C" {
    pub fn pango2_attr_type_get_name(type_: guint) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pango2_attribute_copy(attr: *const Pango2Attribute) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attribute_destroy(attr: *mut Pango2Attribute);
}
extern "C" {
    pub fn pango2_attribute_equal(
        attr1: *const Pango2Attribute,
        attr2: *const Pango2Attribute,
    ) -> gboolean;
}
extern "C" {
    pub fn pango2_attribute_new(type_: guint, value: gconstpointer) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attribute_type(attribute: *const Pango2Attribute) -> guint;
}
extern "C" {
    pub fn pango2_attribute_set_range(
        attribute: *mut Pango2Attribute,
        start_index: guint,
        end_index: guint,
    );
}
extern "C" {
    pub fn pango2_attribute_get_range(
        attribute: *mut Pango2Attribute,
        start_index: *mut guint,
        end_index: *mut guint,
    );
}
extern "C" {
    pub fn pango2_attribute_get_string(
        attribute: *mut Pango2Attribute,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pango2_attribute_get_language(attribute: *mut Pango2Attribute) -> *mut Pango2Language;
}
extern "C" {
    pub fn pango2_attribute_get_int(attribute: *mut Pango2Attribute) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_attribute_get_boolean(attribute: *mut Pango2Attribute) -> gboolean;
}
extern "C" {
    pub fn pango2_attribute_get_float(attribute: *mut Pango2Attribute) -> f64;
}
extern "C" {
    pub fn pango2_attribute_get_color(attribute: *mut Pango2Attribute) -> *mut Pango2Color;
}
extern "C" {
    pub fn pango2_attribute_get_font_desc(
        attribute: *mut Pango2Attribute,
    ) -> *mut Pango2FontDescription;
}
extern "C" {
    pub fn pango2_attribute_get_pointer(attribute: *mut Pango2Attribute) -> gpointer;
}
extern "C" {
    pub fn pango2_attr_language_new(language: *mut Pango2Language) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_family_new(family: *const ::std::os::raw::c_char) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_foreground_new(color: *mut Pango2Color) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_background_new(color: *mut Pango2Color) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_size_new(size: ::std::os::raw::c_int) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_size_new_absolute(size: ::std::os::raw::c_int) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_style_new(style: Pango2Style) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_weight_new(weight: Pango2Weight) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_variant_new(variant: Pango2Variant) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_stretch_new(stretch: Pango2Stretch) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_font_desc_new(desc: *const Pango2FontDescription) -> *mut Pango2Attribute;
}
pub const Pango2LineStyle_PANGO2_LINE_STYLE_NONE: Pango2LineStyle = 0;
pub const Pango2LineStyle_PANGO2_LINE_STYLE_SOLID: Pango2LineStyle = 1;
pub const Pango2LineStyle_PANGO2_LINE_STYLE_DOUBLE: Pango2LineStyle = 2;
pub const Pango2LineStyle_PANGO2_LINE_STYLE_DASHED: Pango2LineStyle = 3;
pub const Pango2LineStyle_PANGO2_LINE_STYLE_DOTTED: Pango2LineStyle = 4;
pub const Pango2LineStyle_PANGO2_LINE_STYLE_WAVY: Pango2LineStyle = 5;
#[doc = " Pango2LineStyle:\n @PANGO2_LINE_STYLE_NONE: No visible line\n @PANGO2_LINE_STYLE_SOLID: A single line\n @PANGO2_LINE_STYLE_DOUBLE: A double line\n @PANGO2_LINE_STYLE_DASHED: A dashed line\n @PANGO2_LINE_STYLE_DOTTED: A dotted line\n @PANGO2_LINE_STYLE_WAVY: A wavy line\n\n `Pango2LineStyle specifies how lines should be drawn."]
pub type Pango2LineStyle = ::std::os::raw::c_uint;
extern "C" {
    pub fn pango2_attr_underline_new(style: Pango2LineStyle) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_underline_color_new(color: *mut Pango2Color) -> *mut Pango2Attribute;
}
pub const Pango2UnderlinePosition_PANGO2_UNDERLINE_POSITION_NORMAL: Pango2UnderlinePosition = 0;
pub const Pango2UnderlinePosition_PANGO2_UNDERLINE_POSITION_UNDER: Pango2UnderlinePosition = 1;
#[doc = " Pango2UnderlinePosition:\n @PANGO2_UNDERLINE_POSITION_NORMAL: As specified by font metrics\n @PANGO2_UNDERLINE_POSITION_UNDER: Below the ink extents of the run\n\n `Pango2UnderlinePosition` specifies where underlines should be drawn."]
pub type Pango2UnderlinePosition = ::std::os::raw::c_uint;
extern "C" {
    pub fn pango2_attr_underline_position_new(
        position: Pango2UnderlinePosition,
    ) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_strikethrough_new(style: Pango2LineStyle) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_strikethrough_color_new(color: *mut Pango2Color) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_rise_new(rise: ::std::os::raw::c_int) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_baseline_shift_new(shift: ::std::os::raw::c_int) -> *mut Pango2Attribute;
}
pub const Pango2FontScale_PANGO2_FONT_SCALE_NONE: Pango2FontScale = 0;
pub const Pango2FontScale_PANGO2_FONT_SCALE_SUPERSCRIPT: Pango2FontScale = 1;
pub const Pango2FontScale_PANGO2_FONT_SCALE_SUBSCRIPT: Pango2FontScale = 2;
pub const Pango2FontScale_PANGO2_FONT_SCALE_SMALL_CAPS: Pango2FontScale = 3;
#[doc = " Pango2FontScale:\n @PANGO2_FONT_SCALE_NONE: Leave the font size unchanged\n @PANGO2_FONT_SCALE_SUPERSCRIPT: Change the font to a size suitable for superscripts\n @PANGO2_FONT_SCALE_SUBSCRIPT: Change the font to a size suitable for subscripts\n @PANGO2_FONT_SCALE_SMALL_CAPS: Change the font to a size suitable for Small Caps\n\n `Pango2FontScale` influences the font size of a run."]
pub type Pango2FontScale = ::std::os::raw::c_uint;
extern "C" {
    pub fn pango2_attr_font_scale_new(scale: Pango2FontScale) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_scale_new(scale_factor: f64) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_fallback_new(enable_fallback: gboolean) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_letter_spacing_new(
        letter_spacing: ::std::os::raw::c_int,
    ) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_gravity_new(gravity: Pango2Gravity) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_gravity_hint_new(hint: Pango2GravityHint) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_font_features_new(
        features: *const ::std::os::raw::c_char,
    ) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_palette_new(palette: *const ::std::os::raw::c_char) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_allow_breaks_new(allow_breaks: gboolean) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_word_new() -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_sentence_new() -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_paragraph_new() -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_insert_hyphens_new(insert_hyphens: gboolean) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_overline_new(style: Pango2LineStyle) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_overline_color_new(color: *mut Pango2Color) -> *mut Pango2Attribute;
}
pub const Pango2ShowFlags_PANGO2_SHOW_NONE: Pango2ShowFlags = 0;
pub const Pango2ShowFlags_PANGO2_SHOW_SPACES: Pango2ShowFlags = 1;
pub const Pango2ShowFlags_PANGO2_SHOW_LINE_BREAKS: Pango2ShowFlags = 2;
pub const Pango2ShowFlags_PANGO2_SHOW_IGNORABLES: Pango2ShowFlags = 4;
#[doc = " Pango2ShowFlags:\n @PANGO2_SHOW_NONE: No special treatment for invisible characters\n @PANGO2_SHOW_SPACES: Render spaces, tabs and newlines visibly\n @PANGO2_SHOW_LINE_BREAKS: Render line breaks visibly\n @PANGO2_SHOW_IGNORABLES: Render default-ignorable Unicode\n   characters visibly\n\n `Pango2ShowFlags` affect how Pango2 treats characters that are normally\n not visible in the output."]
pub type Pango2ShowFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn pango2_attr_show_new(flags: Pango2ShowFlags) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_line_height_new(factor: f64) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_line_height_new_absolute(
        height: ::std::os::raw::c_int,
    ) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_line_spacing_new(spacing: ::std::os::raw::c_int) -> *mut Pango2Attribute;
}
pub const Pango2TextTransform_PANGO2_TEXT_TRANSFORM_NONE: Pango2TextTransform = 0;
pub const Pango2TextTransform_PANGO2_TEXT_TRANSFORM_LOWERCASE: Pango2TextTransform = 1;
pub const Pango2TextTransform_PANGO2_TEXT_TRANSFORM_UPPERCASE: Pango2TextTransform = 2;
pub const Pango2TextTransform_PANGO2_TEXT_TRANSFORM_CAPITALIZE: Pango2TextTransform = 3;
#[doc = " Pango2TextTransform:\n @PANGO2_TEXT_TRANSFORM_NONE: Leave text unchanged\n @PANGO2_TEXT_TRANSFORM_LOWERCASE: Display letters and numbers as lowercase\n @PANGO2_TEXT_TRANSFORM_UPPERCASE: Display letters and numbers as uppercase\n @PANGO2_TEXT_TRANSFORM_CAPITALIZE: Display the first character of a word\n   in titlecase\n\n `Pango2TextTransform` determines if Pango2 changes the case of characters\n during shaping."]
pub type Pango2TextTransform = ::std::os::raw::c_uint;
extern "C" {
    pub fn pango2_attr_text_transform_new(transform: Pango2TextTransform) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_shape_new(
        ink_rect: *mut Pango2Rectangle,
        logical_rect: *mut Pango2Rectangle,
        data: gpointer,
        copy: Pango2AttrDataCopyFunc,
        destroy: GDestroyNotify,
    ) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_emoji_presentation_new(
        presentation: Pango2EmojiPresentation,
    ) -> *mut Pango2Attribute;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2AttrList {
    _unused: [u8; 0],
}
pub type Pango2AttrList = _Pango2AttrList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2AttrIterator {
    _unused: [u8; 0],
}
pub type Pango2AttrIterator = _Pango2AttrIterator;
extern "C" {
    #[doc = " Pango2AttrList:\n\n A `Pango2AttrList` represents a list of attributes that apply to a section\n of text.\n\n The attributes in a `Pango2AttrList` are, in general, allowed to overlap in\n an arbitrary fashion. However, if the attributes are manipulated only through\n [method@Pango2.AttrList.change], the overlap between properties will meet\n stricter criteria."]
    pub fn pango2_attr_list_get_type() -> GType;
}
extern "C" {
    pub fn pango2_attr_list_new() -> *mut Pango2AttrList;
}
extern "C" {
    pub fn pango2_attr_list_ref(list: *mut Pango2AttrList) -> *mut Pango2AttrList;
}
extern "C" {
    pub fn pango2_attr_list_unref(list: *mut Pango2AttrList);
}
extern "C" {
    pub fn pango2_attr_list_copy(list: *mut Pango2AttrList) -> *mut Pango2AttrList;
}
extern "C" {
    pub fn pango2_attr_list_insert(list: *mut Pango2AttrList, attr: *mut Pango2Attribute);
}
extern "C" {
    pub fn pango2_attr_list_insert_before(list: *mut Pango2AttrList, attr: *mut Pango2Attribute);
}
extern "C" {
    pub fn pango2_attr_list_change(list: *mut Pango2AttrList, attr: *mut Pango2Attribute);
}
extern "C" {
    pub fn pango2_attr_list_splice(
        list: *mut Pango2AttrList,
        other: *mut Pango2AttrList,
        pos: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_attr_list_update(
        list: *mut Pango2AttrList,
        pos: ::std::os::raw::c_int,
        remove: ::std::os::raw::c_int,
        add: ::std::os::raw::c_int,
    );
}
#[doc = " Pango2AttrFilterFunc:\n @attribute: a Pango attribute\n @user_data: user data passed to the function\n\n Callback to filter a list of attributes.\n\n Return value: `TRUE` if the attribute should be selected for\n   filtering, `FALSE` otherwise."]
pub type Pango2AttrFilterFunc = ::std::option::Option<
    unsafe extern "C" fn(attribute: *mut Pango2Attribute, user_data: gpointer) -> gboolean,
>;
extern "C" {
    pub fn pango2_attr_list_filter(
        list: *mut Pango2AttrList,
        func: Pango2AttrFilterFunc,
        data: gpointer,
    ) -> *mut Pango2AttrList;
}
extern "C" {
    pub fn pango2_attr_list_get_attributes(list: *mut Pango2AttrList) -> *mut GSList;
}
extern "C" {
    pub fn pango2_attr_list_equal(
        list: *mut Pango2AttrList,
        other_list: *mut Pango2AttrList,
    ) -> gboolean;
}
extern "C" {
    pub fn pango2_attr_list_to_string(list: *mut Pango2AttrList) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pango2_attr_list_from_string(text: *const ::std::os::raw::c_char)
        -> *mut Pango2AttrList;
}
extern "C" {
    pub fn pango2_attr_list_get_iterator(list: *mut Pango2AttrList) -> *mut Pango2AttrIterator;
}
extern "C" {
    #[doc = " Pango2AttrIterator:\n\n A `Pango2AttrIterator` is used to iterate through a `Pango2AttrList`.\n\n A new iterator is created with [method@Pango2.AttrList.get_iterator].\n Once the iterator is created, it can be advanced through the style\n changes in the text using [method@Pango2.AttrIterator.next]. At each\n style change, the range of the current style segment and the attributes\n currently in effect can be queried."]
    pub fn pango2_attr_iterator_get_type() -> GType;
}
extern "C" {
    pub fn pango2_attr_iterator_range(
        iterator: *mut Pango2AttrIterator,
        start: *mut ::std::os::raw::c_int,
        end: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_attr_iterator_next(iterator: *mut Pango2AttrIterator) -> gboolean;
}
extern "C" {
    pub fn pango2_attr_iterator_copy(iterator: *mut Pango2AttrIterator) -> *mut Pango2AttrIterator;
}
extern "C" {
    pub fn pango2_attr_iterator_destroy(iterator: *mut Pango2AttrIterator);
}
extern "C" {
    pub fn pango2_attr_iterator_get(
        iterator: *mut Pango2AttrIterator,
        type_: guint,
    ) -> *mut Pango2Attribute;
}
extern "C" {
    pub fn pango2_attr_iterator_get_font(
        iterator: *mut Pango2AttrIterator,
        desc: *mut Pango2FontDescription,
        language: *mut *mut Pango2Language,
        extra_attrs: *mut *mut GSList,
    );
}
extern "C" {
    pub fn pango2_attr_iterator_get_attrs(iterator: *mut Pango2AttrIterator) -> *mut GSList;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2Analysis {
    _unused: [u8; 0],
}
pub type Pango2Analysis = _Pango2Analysis;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2Item {
    _unused: [u8; 0],
}
pub type Pango2Item = _Pango2Item;
extern "C" {
    pub fn pango2_item_get_type() -> GType;
}
extern "C" {
    pub fn pango2_item_copy(item: *mut Pango2Item) -> *mut Pango2Item;
}
extern "C" {
    pub fn pango2_item_free(item: *mut Pango2Item);
}
extern "C" {
    pub fn pango2_itemize(
        context: *mut Pango2Context,
        base_dir: Pango2Direction,
        text: *const ::std::os::raw::c_char,
        start_index: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
        attrs: *mut Pango2AttrList,
    ) -> *mut GList;
}
extern "C" {
    pub fn pango2_analysis_get_font(analysis: *const Pango2Analysis) -> *mut Pango2Font;
}
extern "C" {
    pub fn pango2_analysis_get_bidi_level(analysis: *const Pango2Analysis)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_analysis_get_gravity(analysis: *const Pango2Analysis) -> Pango2Gravity;
}
extern "C" {
    pub fn pango2_analysis_get_flags(analysis: *const Pango2Analysis) -> guint;
}
extern "C" {
    pub fn pango2_analysis_get_script(analysis: *const Pango2Analysis) -> GUnicodeScript;
}
extern "C" {
    pub fn pango2_analysis_get_language(analysis: *const Pango2Analysis) -> *mut Pango2Language;
}
extern "C" {
    pub fn pango2_analysis_get_extra_attributes(analysis: *const Pango2Analysis) -> *mut GSList;
}
extern "C" {
    pub fn pango2_item_get_analysis(item: *mut Pango2Item) -> *const Pango2Analysis;
}
extern "C" {
    pub fn pango2_item_get_byte_offset(item: *mut Pango2Item) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_item_get_byte_length(item: *mut Pango2Item) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_item_get_char_offset(item: *mut Pango2Item) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_item_get_char_length(item: *mut Pango2Item) -> ::std::os::raw::c_int;
}
#[doc = " Pango2LogAttr:\n @is_line_break: if set, can break line in front of character\n @is_mandatory_break: if set, must break line in front of character\n @is_char_break: if set, can break here when doing character wrapping\n @is_white: is whitespace character\n @is_cursor_position: if set, cursor can appear in front of character.\n   i.e. this is a grapheme boundary, or the first character in the text.\n   This flag implements Unicode's\n   [Grapheme Cluster Boundaries](http://www.unicode.org/reports/tr29/)\n   semantics.\n @is_word_start: is first character in a word\n @is_word_end: is first non-word char after a word\n   Note that in degenerate cases, you could have both @is_word_start\n   and @is_word_end set for some character.\n @is_sentence_boundary: is a sentence boundary.\n   There are two ways to divide sentences. The first assigns all\n   inter-sentence whitespace/control/format chars to some sentence,\n   so all chars are in some sentence; @is_sentence_boundary denotes\n   the boundaries there. The second way doesn't assign\n   between-sentence spaces, etc. to any sentence, so\n   @is_sentence_start/@is_sentence_end mark the boundaries of those sentences.\n @is_sentence_start: is first character in a sentence\n @is_sentence_end: is first char after a sentence.\n   Note that in degenerate cases, you could have both @is_sentence_start\n   and @is_sentence_end set for some character. (e.g. no space after a\n   period, so the next sentence starts right away)\n @backspace_deletes_character: if set, backspace deletes one character\n   rather than the entire grapheme cluster. This field is only meaningful\n   on grapheme boundaries (where @is_cursor_position is set). In some languages,\n   the full grapheme (e.g. letter + diacritics) is considered a unit, while in\n   others, each decomposed character in the grapheme is a unit. In the default\n   implementation of [func@default_break], this bit is set on all grapheme\n   boundaries except those following Latin, Cyrillic or Greek base characters.\n @is_expandable_space: is a whitespace character that can possibly be\n   expanded for justification purposes.\n @is_word_boundary: is a word boundary, as defined by UAX#29.\n   More specifically, means that this is not a position in the middle of a word.\n   For example, both sides of a punctuation mark are considered word boundaries.\n   This flag is particularly useful when selecting text word-by-word. This flag\n   implements Unicode's [Word Boundaries](http://www.unicode.org/reports/tr29/)\n   semantics.\n @break_inserts_hyphen: when breaking lines before this char, insert a hyphen.\n @break_removes_preceding: when breaking lines before this char, remove the\n   preceding char.\n\n The `Pango2LogAttr` structure stores information about the attributes of a\n single character."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2LogAttr {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__Pango2LogAttr() {
    assert_eq!(
        ::std::mem::size_of::<_Pango2LogAttr>(),
        4usize,
        concat!("Size of: ", stringify!(_Pango2LogAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<_Pango2LogAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(_Pango2LogAttr))
    );
}
impl _Pango2LogAttr {
    #[inline]
    pub fn is_line_break(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_line_break(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_mandatory_break(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_mandatory_break(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_char_break(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_char_break(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_white(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_white(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_cursor_position(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_cursor_position(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_word_start(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_word_start(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_word_end(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_word_end(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_sentence_boundary(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_sentence_boundary(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_sentence_start(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_sentence_start(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_sentence_end(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_sentence_end(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn backspace_deletes_character(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_backspace_deletes_character(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_expandable_space(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_expandable_space(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_word_boundary(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_word_boundary(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn break_inserts_hyphen(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_break_inserts_hyphen(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn break_removes_preceding(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_break_removes_preceding(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_line_break: guint,
        is_mandatory_break: guint,
        is_char_break: guint,
        is_white: guint,
        is_cursor_position: guint,
        is_word_start: guint,
        is_word_end: guint,
        is_sentence_boundary: guint,
        is_sentence_start: guint,
        is_sentence_end: guint,
        backspace_deletes_character: guint,
        is_expandable_space: guint,
        is_word_boundary: guint,
        break_inserts_hyphen: guint,
        break_removes_preceding: guint,
        reserved: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_line_break: u32 = unsafe { ::std::mem::transmute(is_line_break) };
            is_line_break as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_mandatory_break: u32 = unsafe { ::std::mem::transmute(is_mandatory_break) };
            is_mandatory_break as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_char_break: u32 = unsafe { ::std::mem::transmute(is_char_break) };
            is_char_break as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_white: u32 = unsafe { ::std::mem::transmute(is_white) };
            is_white as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_cursor_position: u32 = unsafe { ::std::mem::transmute(is_cursor_position) };
            is_cursor_position as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_word_start: u32 = unsafe { ::std::mem::transmute(is_word_start) };
            is_word_start as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let is_word_end: u32 = unsafe { ::std::mem::transmute(is_word_end) };
            is_word_end as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let is_sentence_boundary: u32 = unsafe { ::std::mem::transmute(is_sentence_boundary) };
            is_sentence_boundary as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let is_sentence_start: u32 = unsafe { ::std::mem::transmute(is_sentence_start) };
            is_sentence_start as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let is_sentence_end: u32 = unsafe { ::std::mem::transmute(is_sentence_end) };
            is_sentence_end as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let backspace_deletes_character: u32 =
                unsafe { ::std::mem::transmute(backspace_deletes_character) };
            backspace_deletes_character as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let is_expandable_space: u32 = unsafe { ::std::mem::transmute(is_expandable_space) };
            is_expandable_space as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let is_word_boundary: u32 = unsafe { ::std::mem::transmute(is_word_boundary) };
            is_word_boundary as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let break_inserts_hyphen: u32 = unsafe { ::std::mem::transmute(break_inserts_hyphen) };
            break_inserts_hyphen as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let break_removes_preceding: u32 =
                unsafe { ::std::mem::transmute(break_removes_preceding) };
            break_removes_preceding as u64
        });
        __bindgen_bitfield_unit.set(15usize, 17u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn pango2_get_log_attrs(
        text: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        attr_list: *mut Pango2AttrList,
        level: ::std::os::raw::c_int,
        language: *mut Pango2Language,
        attrs: *mut Pango2LogAttr,
        attrs_len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_default_break(
        text: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        attrs: *mut Pango2LogAttr,
        attrs_len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_tailor_break(
        text: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        analysis: *mut Pango2Analysis,
        offset: ::std::os::raw::c_int,
        attrs: *mut Pango2LogAttr,
        attrs_len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_attr_break(
        text: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        attr_list: *mut Pango2AttrList,
        offset: ::std::os::raw::c_int,
        attrs: *mut Pango2LogAttr,
        attrs_len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_fontset_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2Fontset {
    _unused: [u8; 0],
}
pub type Pango2Fontset = _Pango2Fontset;
#[doc = " Pango2FontsetForeachFunc:\n @fontset: a `Pango2Fontset`\n @font: a font from @fontset\n @user_data: callback data\n\n Callback used when enumerating fonts in a fontset.\n\n See [method@Pango2.Fontset.foreach].\n\n Returns: if %TRUE, stop iteration and return immediately."]
pub type Pango2FontsetForeachFunc = ::std::option::Option<
    unsafe extern "C" fn(
        fontset: *mut Pango2Fontset,
        font: *mut Pango2Font,
        user_data: gpointer,
    ) -> gboolean,
>;
extern "C" {
    pub fn pango2_fontset_get_font(fontset: *mut Pango2Fontset, wc: guint) -> *mut Pango2Font;
}
extern "C" {
    pub fn pango2_fontset_get_metrics(fontset: *mut Pango2Fontset) -> *mut Pango2FontMetrics;
}
extern "C" {
    pub fn pango2_fontset_foreach(
        fontset: *mut Pango2Fontset,
        func: Pango2FontsetForeachFunc,
        data: gpointer,
    );
}
extern "C" {
    pub fn pango2_font_face_get_type() -> GType;
}
extern "C" {
    pub fn pango2_font_face_describe(face: *mut Pango2FontFace) -> *mut Pango2FontDescription;
}
extern "C" {
    pub fn pango2_font_face_get_name(face: *mut Pango2FontFace) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pango2_font_face_is_synthesized(face: *mut Pango2FontFace) -> gboolean;
}
extern "C" {
    pub fn pango2_font_face_is_monospace(face: *mut Pango2FontFace) -> gboolean;
}
extern "C" {
    pub fn pango2_font_face_is_variable(face: *mut Pango2FontFace) -> gboolean;
}
extern "C" {
    pub fn pango2_font_face_get_family(face: *mut Pango2FontFace) -> *mut Pango2FontFamily;
}
extern "C" {
    pub fn pango2_font_face_supports_language(
        face: *mut Pango2FontFace,
        language: *mut Pango2Language,
    ) -> gboolean;
}
extern "C" {
    pub fn pango2_font_face_get_languages(face: *mut Pango2FontFace) -> *mut *mut Pango2Language;
}
extern "C" {
    pub fn pango2_font_face_has_char(face: *mut Pango2FontFace, wc: gunichar) -> gboolean;
}
extern "C" {
    pub fn pango2_hb_face_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2HbFace {
    _unused: [u8; 0],
}
pub type Pango2HbFace = _Pango2HbFace;
extern "C" {
    pub fn pango2_hb_face_new_from_hb_face(
        face: *mut hb_face_t,
        instance_id: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        description: *const Pango2FontDescription,
    ) -> *mut Pango2HbFace;
}
extern "C" {
    pub fn pango2_hb_face_new_from_file(
        file: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_uint,
        instance_id: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        description: *const Pango2FontDescription,
    ) -> *mut Pango2HbFace;
}
extern "C" {
    pub fn pango2_hb_face_get_hb_face(self_: *mut Pango2HbFace) -> *mut hb_face_t;
}
extern "C" {
    pub fn pango2_hb_face_get_file(self_: *mut Pango2HbFace) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pango2_hb_face_get_face_index(self_: *mut Pango2HbFace) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn pango2_hb_face_get_instance_id(self_: *mut Pango2HbFace) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_hb_face_get_variations(
        self_: *mut Pango2HbFace,
        n_variations: *mut ::std::os::raw::c_uint,
    ) -> *const hb_variation_t;
}
extern "C" {
    pub fn pango2_hb_face_get_embolden(self_: *mut Pango2HbFace) -> gboolean;
}
extern "C" {
    pub fn pango2_hb_face_get_transform(self_: *mut Pango2HbFace) -> *const Pango2Matrix;
}
extern "C" {
    pub fn pango2_hb_face_set_palette_name(
        self_: *mut Pango2HbFace,
        name: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn pango2_hb_face_get_palette_name(
        self_: *mut Pango2HbFace,
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2HbFaceBuilder {
    _unused: [u8; 0],
}
pub type Pango2HbFaceBuilder = _Pango2HbFaceBuilder;
extern "C" {
    pub fn pango2_hb_face_builder_get_type() -> GType;
}
extern "C" {
    pub fn pango2_hb_face_builder_copy(src: *const Pango2HbFaceBuilder)
        -> *mut Pango2HbFaceBuilder;
}
extern "C" {
    pub fn pango2_hb_face_builder_free(builder: *mut Pango2HbFaceBuilder);
}
extern "C" {
    pub fn pango2_hb_face_builder_new(face: *mut Pango2HbFace) -> *mut Pango2HbFaceBuilder;
}
extern "C" {
    pub fn pango2_hb_face_builder_new_for_hb_face(
        hb_face: *mut hb_face_t,
    ) -> *mut Pango2HbFaceBuilder;
}
extern "C" {
    pub fn pango2_hb_face_builder_get_face(builder: *mut Pango2HbFaceBuilder) -> *mut Pango2HbFace;
}
extern "C" {
    pub fn pango2_hb_face_builder_set_instance_id(
        builder: *mut Pango2HbFaceBuilder,
        instance_id: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_hb_face_builder_set_name(
        builder: *mut Pango2HbFaceBuilder,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pango2_hb_face_builder_set_description(
        builder: *mut Pango2HbFaceBuilder,
        desc: *const Pango2FontDescription,
    );
}
extern "C" {
    pub fn pango2_hb_face_builder_set_transform(
        builder: *mut Pango2HbFaceBuilder,
        transform: *const Pango2Matrix,
    );
}
extern "C" {
    pub fn pango2_hb_face_builder_set_embolden(
        builder: *mut Pango2HbFaceBuilder,
        embolden: gboolean,
    );
}
extern "C" {
    pub fn pango2_hb_face_builder_set_variations(
        builder: *mut Pango2HbFaceBuilder,
        variations: *const hb_variation_t,
        n_variations: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn pango2_font_map_get_type() -> GType;
}
extern "C" {
    pub fn pango2_font_map_load_font(
        self_: *mut Pango2FontMap,
        context: *mut Pango2Context,
        desc: *const Pango2FontDescription,
    ) -> *mut Pango2Font;
}
extern "C" {
    pub fn pango2_font_map_load_fontset(
        self_: *mut Pango2FontMap,
        context: *mut Pango2Context,
        desc: *const Pango2FontDescription,
        language: *mut Pango2Language,
    ) -> *mut Pango2Fontset;
}
extern "C" {
    pub fn pango2_font_map_get_serial(self_: *mut Pango2FontMap) -> guint;
}
extern "C" {
    pub fn pango2_font_map_get_family(
        self_: *mut Pango2FontMap,
        name: *const ::std::os::raw::c_char,
    ) -> *mut Pango2FontFamily;
}
extern "C" {
    pub fn pango2_font_map_new() -> *mut Pango2FontMap;
}
extern "C" {
    pub fn pango2_font_map_add_file(self_: *mut Pango2FontMap, file: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn pango2_font_map_add_face(self_: *mut Pango2FontMap, face: *mut Pango2FontFace);
}
extern "C" {
    pub fn pango2_font_map_remove_face(self_: *mut Pango2FontMap, face: *mut Pango2FontFace);
}
extern "C" {
    pub fn pango2_font_map_add_family(self_: *mut Pango2FontMap, family: *mut Pango2FontFamily);
}
extern "C" {
    pub fn pango2_font_map_remove_family(self_: *mut Pango2FontMap, family: *mut Pango2FontFamily);
}
extern "C" {
    pub fn pango2_font_map_set_fallback(self_: *mut Pango2FontMap, fallback: *mut Pango2FontMap);
}
extern "C" {
    pub fn pango2_font_map_get_fallback(self_: *mut Pango2FontMap) -> *mut Pango2FontMap;
}
extern "C" {
    pub fn pango2_font_map_get_resolution(self_: *mut Pango2FontMap) -> f32;
}
extern "C" {
    pub fn pango2_font_map_set_resolution(self_: *mut Pango2FontMap, dpi: f32);
}
extern "C" {
    pub fn pango2_font_map_new_default() -> *mut Pango2FontMap;
}
extern "C" {
    pub fn pango2_font_map_get_default() -> *mut Pango2FontMap;
}
extern "C" {
    pub fn pango2_font_map_set_default(fontmap: *mut Pango2FontMap);
}
extern "C" {
    pub fn pango2_context_get_type() -> GType;
}
extern "C" {
    pub fn pango2_context_new() -> *mut Pango2Context;
}
extern "C" {
    pub fn pango2_context_new_with_font_map(font_map: *mut Pango2FontMap) -> *mut Pango2Context;
}
extern "C" {
    pub fn pango2_context_changed(context: *mut Pango2Context);
}
extern "C" {
    pub fn pango2_context_set_font_map(context: *mut Pango2Context, font_map: *mut Pango2FontMap);
}
extern "C" {
    pub fn pango2_context_get_font_map(context: *mut Pango2Context) -> *mut Pango2FontMap;
}
extern "C" {
    pub fn pango2_context_get_serial(context: *mut Pango2Context) -> guint;
}
extern "C" {
    pub fn pango2_context_load_font(
        context: *mut Pango2Context,
        desc: *const Pango2FontDescription,
    ) -> *mut Pango2Font;
}
extern "C" {
    pub fn pango2_context_load_fontset(
        context: *mut Pango2Context,
        desc: *const Pango2FontDescription,
        language: *mut Pango2Language,
    ) -> *mut Pango2Fontset;
}
extern "C" {
    pub fn pango2_context_get_metrics(
        context: *mut Pango2Context,
        desc: *const Pango2FontDescription,
        language: *mut Pango2Language,
    ) -> *mut Pango2FontMetrics;
}
extern "C" {
    pub fn pango2_context_set_font_description(
        context: *mut Pango2Context,
        desc: *const Pango2FontDescription,
    );
}
extern "C" {
    pub fn pango2_context_get_font_description(
        context: *mut Pango2Context,
    ) -> *mut Pango2FontDescription;
}
extern "C" {
    pub fn pango2_context_get_language(context: *mut Pango2Context) -> *mut Pango2Language;
}
extern "C" {
    pub fn pango2_context_set_language(context: *mut Pango2Context, language: *mut Pango2Language);
}
extern "C" {
    pub fn pango2_context_set_base_dir(context: *mut Pango2Context, direction: Pango2Direction);
}
extern "C" {
    pub fn pango2_context_get_base_dir(context: *mut Pango2Context) -> Pango2Direction;
}
extern "C" {
    pub fn pango2_context_set_base_gravity(context: *mut Pango2Context, gravity: Pango2Gravity);
}
extern "C" {
    pub fn pango2_context_get_base_gravity(context: *mut Pango2Context) -> Pango2Gravity;
}
extern "C" {
    pub fn pango2_context_get_gravity(context: *mut Pango2Context) -> Pango2Gravity;
}
extern "C" {
    pub fn pango2_context_set_gravity_hint(context: *mut Pango2Context, hint: Pango2GravityHint);
}
extern "C" {
    pub fn pango2_context_get_gravity_hint(context: *mut Pango2Context) -> Pango2GravityHint;
}
extern "C" {
    pub fn pango2_context_set_matrix(context: *mut Pango2Context, matrix: *const Pango2Matrix);
}
extern "C" {
    pub fn pango2_context_get_matrix(context: *mut Pango2Context) -> *const Pango2Matrix;
}
extern "C" {
    pub fn pango2_context_set_round_glyph_positions(
        context: *mut Pango2Context,
        round_positions: gboolean,
    );
}
extern "C" {
    pub fn pango2_context_get_round_glyph_positions(context: *mut Pango2Context) -> gboolean;
}
extern "C" {
    pub fn pango2_context_set_palette(
        context: *mut Pango2Context,
        palette: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pango2_context_get_palette(context: *mut Pango2Context)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pango2_context_set_emoji_presentation(
        context: *mut Pango2Context,
        presentation: Pango2EmojiPresentation,
    );
}
extern "C" {
    pub fn pango2_context_get_emoji_presentation(
        context: *mut Pango2Context,
    ) -> Pango2EmojiPresentation;
}
extern "C" {
    pub fn pango2_attr_value_type_get_type() -> GType;
}
extern "C" {
    pub fn pango2_attr_affects_get_type() -> GType;
}
extern "C" {
    pub fn pango2_attr_merge_get_type() -> GType;
}
extern "C" {
    pub fn pango2_attr_type_get_type() -> GType;
}
extern "C" {
    pub fn pango2_line_style_get_type() -> GType;
}
extern "C" {
    pub fn pango2_underline_position_get_type() -> GType;
}
extern "C" {
    pub fn pango2_baseline_shift_get_type() -> GType;
}
extern "C" {
    pub fn pango2_font_scale_get_type() -> GType;
}
extern "C" {
    pub fn pango2_show_flags_get_type() -> GType;
}
extern "C" {
    pub fn pango2_text_transform_get_type() -> GType;
}
extern "C" {
    pub fn pango2_direction_get_type() -> GType;
}
extern "C" {
    pub fn pango2_style_get_type() -> GType;
}
extern "C" {
    pub fn pango2_variant_get_type() -> GType;
}
extern "C" {
    pub fn pango2_weight_get_type() -> GType;
}
extern "C" {
    pub fn pango2_stretch_get_type() -> GType;
}
extern "C" {
    pub fn pango2_font_mask_get_type() -> GType;
}
extern "C" {
    pub fn pango2_shape_flags_get_type() -> GType;
}
extern "C" {
    pub fn pango2_gravity_get_type() -> GType;
}
extern "C" {
    pub fn pango2_gravity_hint_get_type() -> GType;
}
extern "C" {
    pub fn pango2_layout_serialize_flags_get_type() -> GType;
}
extern "C" {
    pub fn pango2_layout_deserialize_error_get_type() -> GType;
}
extern "C" {
    pub fn pango2_layout_deserialize_flags_get_type() -> GType;
}
extern "C" {
    pub fn pango2_render_part_get_type() -> GType;
}
extern "C" {
    pub fn pango2_tab_align_get_type() -> GType;
}
extern "C" {
    pub fn pango2_tab_positions_get_type() -> GType;
}
extern "C" {
    pub fn pango2_alignment_get_type() -> GType;
}
extern "C" {
    pub fn pango2_wrap_mode_get_type() -> GType;
}
extern "C" {
    pub fn pango2_ellipsize_mode_get_type() -> GType;
}
extern "C" {
    pub fn pango2_leading_trim_get_type() -> GType;
}
extern "C" {
    pub fn pango2_emoji_presentation_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GListModel {
    _unused: [u8; 0],
}
pub type GListModel = _GListModel;
extern "C" {
    pub fn pango2_generic_family_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2GenericFamily {
    _unused: [u8; 0],
}
pub type Pango2GenericFamily = _Pango2GenericFamily;
extern "C" {
    pub fn pango2_generic_family_new(
        name: *const ::std::os::raw::c_char,
    ) -> *mut Pango2GenericFamily;
}
extern "C" {
    pub fn pango2_generic_family_add_family(
        self_: *mut Pango2GenericFamily,
        family: *mut Pango2FontFamily,
    );
}
extern "C" {
    pub fn pango2_generic_family_get_families(self_: *mut Pango2GenericFamily) -> *mut GListModel;
}
#[doc = " Pango2GlyphGeometry:\n @width: the logical width to use for the the character.\n @x_offset: horizontal offset from nominal character position.\n @y_offset: vertical offset from nominal character position.\n\n The `Pango2GlyphGeometry` structure contains width and positioning\n information for a single glyph.\n\n Note that @width is not guaranteed to be the same as the glyph\n extents. Kerning and other positioning applied during shaping will\n affect both the @width and the @x_offset for the glyphs in the\n glyph string that results from shaping.\n\n The information in this struct is intended for rendering the glyphs,\n as follows:\n\n 1. Assume the current point is (x, y)\n 2. Render the current glyph at (x + x_offset, y + y_offset),\n 3. Advance the current point to (x + width, y)\n 4. Render the next glyph"]
pub type Pango2GlyphGeometry = _Pango2GlyphGeometry;
#[doc = " Pango2GlyphVisAttr:\n @is_cluster_start: set for the first logical glyph in each cluster.\n @is_color: set if the the font will render this glyph with color. Since 1.50\n\n A `Pango2GlyphVisAttr` structure communicates information between\n the shaping and rendering phases.\n\n Currently, it contains cluster start and color information.\n More attributes may be added in the future.\n\n Clusters are stored in visual order, within the cluster, glyphs\n are always ordered in logical order, since visual order is meaningless;\n that is, in Arabic text, accent glyphs follow the glyphs for the\n base character."]
pub type Pango2GlyphVisAttr = _Pango2GlyphVisAttr;
#[doc = " Pango2GlyphInfo:\n @glyph: the glyph itself.\n @geometry: the positional information about the glyph.\n @attr: the visual attributes of the glyph.\n\n A `Pango2GlyphInfo` structure represents a single glyph with\n positioning information and visual attributes."]
pub type Pango2GlyphInfo = _Pango2GlyphInfo;
#[doc = " Pango2GlyphString:\n @num_glyphs: number of glyphs in this glyph string\n @glyphs: (array length=num_glyphs): array of glyph information\n @log_clusters: logical cluster info, indexed by the byte index\n   within the text corresponding to the glyph string\n\n A `Pango2GlyphString` is used to store strings of glyphs with geometry\n and visual attribute information.\n\n The storage for the glyph information is owned by the structure\n which simplifies memory management."]
pub type Pango2GlyphString = _Pango2GlyphString;
#[doc = " Pango2GlyphUnit:\n\n The `Pango2GlyphUnit` type is used to store dimensions within\n Pango2.\n\n Dimensions are stored in 1/PANGO2_SCALE of a device unit.\n (A device unit might be a pixel for screen display, or\n a point on a printer.) PANGO2_SCALE is currently 1024, and\n may change in the future (unlikely though), but you should not\n depend on its exact value.\n\n The PANGO2_PIXELS() macro can be used to convert from glyph units\n into device units with correct rounding."]
pub type Pango2GlyphUnit = gint32;
#[doc = " Pango2GlyphGeometry:\n @width: the logical width to use for the the character.\n @x_offset: horizontal offset from nominal character position.\n @y_offset: vertical offset from nominal character position.\n\n The `Pango2GlyphGeometry` structure contains width and positioning\n information for a single glyph.\n\n Note that @width is not guaranteed to be the same as the glyph\n extents. Kerning and other positioning applied during shaping will\n affect both the @width and the @x_offset for the glyphs in the\n glyph string that results from shaping.\n\n The information in this struct is intended for rendering the glyphs,\n as follows:\n\n 1. Assume the current point is (x, y)\n 2. Render the current glyph at (x + x_offset, y + y_offset),\n 3. Advance the current point to (x + width, y)\n 4. Render the next glyph"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2GlyphGeometry {
    pub width: Pango2GlyphUnit,
    pub x_offset: Pango2GlyphUnit,
    pub y_offset: Pango2GlyphUnit,
}
#[test]
fn bindgen_test_layout__Pango2GlyphGeometry() {
    const UNINIT: ::std::mem::MaybeUninit<_Pango2GlyphGeometry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Pango2GlyphGeometry>(),
        12usize,
        concat!("Size of: ", stringify!(_Pango2GlyphGeometry))
    );
    assert_eq!(
        ::std::mem::align_of::<_Pango2GlyphGeometry>(),
        4usize,
        concat!("Alignment of ", stringify!(_Pango2GlyphGeometry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2GlyphGeometry),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2GlyphGeometry),
            "::",
            stringify!(x_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2GlyphGeometry),
            "::",
            stringify!(y_offset)
        )
    );
}
#[doc = " Pango2GlyphVisAttr:\n @is_cluster_start: set for the first logical glyph in each cluster.\n @is_color: set if the the font will render this glyph with color. Since 1.50\n\n A `Pango2GlyphVisAttr` structure communicates information between\n the shaping and rendering phases.\n\n Currently, it contains cluster start and color information.\n More attributes may be added in the future.\n\n Clusters are stored in visual order, within the cluster, glyphs\n are always ordered in logical order, since visual order is meaningless;\n that is, in Arabic text, accent glyphs follow the glyphs for the\n base character."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2GlyphVisAttr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout__Pango2GlyphVisAttr() {
    assert_eq!(
        ::std::mem::size_of::<_Pango2GlyphVisAttr>(),
        4usize,
        concat!("Size of: ", stringify!(_Pango2GlyphVisAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<_Pango2GlyphVisAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(_Pango2GlyphVisAttr))
    );
}
impl _Pango2GlyphVisAttr {
    #[inline]
    pub fn is_cluster_start(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_cluster_start(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_color(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_color(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_cluster_start: guint,
        is_color: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_cluster_start: u32 = unsafe { ::std::mem::transmute(is_cluster_start) };
            is_cluster_start as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_color: u32 = unsafe { ::std::mem::transmute(is_color) };
            is_color as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Pango2GlyphInfo:\n @glyph: the glyph itself.\n @geometry: the positional information about the glyph.\n @attr: the visual attributes of the glyph.\n\n A `Pango2GlyphInfo` structure represents a single glyph with\n positioning information and visual attributes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2GlyphInfo {
    pub glyph: Pango2Glyph,
    pub geometry: Pango2GlyphGeometry,
    pub attr: Pango2GlyphVisAttr,
}
#[test]
fn bindgen_test_layout__Pango2GlyphInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_Pango2GlyphInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Pango2GlyphInfo>(),
        20usize,
        concat!("Size of: ", stringify!(_Pango2GlyphInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_Pango2GlyphInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(_Pango2GlyphInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).glyph) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2GlyphInfo),
            "::",
            stringify!(glyph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geometry) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2GlyphInfo),
            "::",
            stringify!(geometry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2GlyphInfo),
            "::",
            stringify!(attr)
        )
    );
}
#[doc = " Pango2GlyphString:\n @num_glyphs: number of glyphs in this glyph string\n @glyphs: (array length=num_glyphs): array of glyph information\n @log_clusters: logical cluster info, indexed by the byte index\n   within the text corresponding to the glyph string\n\n A `Pango2GlyphString` is used to store strings of glyphs with geometry\n and visual attribute information.\n\n The storage for the glyph information is owned by the structure\n which simplifies memory management."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2GlyphString {
    pub num_glyphs: ::std::os::raw::c_int,
    pub glyphs: *mut Pango2GlyphInfo,
    pub log_clusters: *mut ::std::os::raw::c_int,
    pub space: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__Pango2GlyphString() {
    const UNINIT: ::std::mem::MaybeUninit<_Pango2GlyphString> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Pango2GlyphString>(),
        32usize,
        concat!("Size of: ", stringify!(_Pango2GlyphString))
    );
    assert_eq!(
        ::std::mem::align_of::<_Pango2GlyphString>(),
        8usize,
        concat!("Alignment of ", stringify!(_Pango2GlyphString))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_glyphs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2GlyphString),
            "::",
            stringify!(num_glyphs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).glyphs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2GlyphString),
            "::",
            stringify!(glyphs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_clusters) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2GlyphString),
            "::",
            stringify!(log_clusters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).space) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2GlyphString),
            "::",
            stringify!(space)
        )
    );
}
extern "C" {
    pub fn pango2_glyph_string_get_type() -> GType;
}
extern "C" {
    pub fn pango2_glyph_string_new() -> *mut Pango2GlyphString;
}
extern "C" {
    pub fn pango2_glyph_string_set_size(
        string: *mut Pango2GlyphString,
        new_len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_glyph_string_copy(string: *mut Pango2GlyphString) -> *mut Pango2GlyphString;
}
extern "C" {
    pub fn pango2_glyph_string_free(string: *mut Pango2GlyphString);
}
extern "C" {
    pub fn pango2_glyph_string_extents(
        glyphs: *mut Pango2GlyphString,
        font: *mut Pango2Font,
        ink_rect: *mut Pango2Rectangle,
        logical_rect: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_glyph_string_get_width(glyphs: *mut Pango2GlyphString) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_glyph_string_extents_range(
        glyphs: *mut Pango2GlyphString,
        start: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
        font: *mut Pango2Font,
        ink_rect: *mut Pango2Rectangle,
        logical_rect: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_glyph_string_get_logical_widths(
        glyphs: *mut Pango2GlyphString,
        text: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        embedding_level: ::std::os::raw::c_int,
        logical_widths: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_glyph_string_index_to_x(
        glyphs: *mut Pango2GlyphString,
        text: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        analysis: *const Pango2Analysis,
        index_: ::std::os::raw::c_int,
        trailing: gboolean,
        x_pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_glyph_string_x_to_index(
        glyphs: *mut Pango2GlyphString,
        text: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        analysis: *const Pango2Analysis,
        x_pos: ::std::os::raw::c_int,
        index_: *mut ::std::os::raw::c_int,
        trailing: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_glyph_string_index_to_x_full(
        glyphs: *mut Pango2GlyphString,
        text: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        analysis: *const Pango2Analysis,
        attrs: *mut Pango2LogAttr,
        index_: ::std::os::raw::c_int,
        trailing: gboolean,
        x_pos: *mut ::std::os::raw::c_int,
    );
}
pub const Pango2ShapeFlags_PANGO2_SHAPE_NONE: Pango2ShapeFlags = 0;
pub const Pango2ShapeFlags_PANGO2_SHAPE_ROUND_POSITIONS: Pango2ShapeFlags = 1;
#[doc = " Pango2ShapeFlags:\n @PANGO2_SHAPE_NONE: Default value\n @PANGO2_SHAPE_ROUND_POSITIONS: Round glyph positions and widths to whole device units\n   This option should be set if the target renderer can't do subpixel positioning of glyphs\n\n `Pango2ShapeFlags` influence the shaping process.\n\n These flags can be passed to [func@Pango2.shape]."]
pub type Pango2ShapeFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn pango2_shape(
        item_text: *const ::std::os::raw::c_char,
        item_length: ::std::os::raw::c_int,
        paragraph_text: *const ::std::os::raw::c_char,
        paragraph_length: ::std::os::raw::c_int,
        analysis: *const Pango2Analysis,
        glyphs: *mut Pango2GlyphString,
        flags: Pango2ShapeFlags,
    );
}
extern "C" {
    pub fn pango2_shape_item(
        item: *mut Pango2Item,
        paragraph_text: *const ::std::os::raw::c_char,
        paragraph_length: ::std::os::raw::c_int,
        log_attrs: *mut Pango2LogAttr,
        glyphs: *mut Pango2GlyphString,
        flags: Pango2ShapeFlags,
    );
}
extern "C" {
    pub fn pango2_hb_font_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2HbFont {
    _unused: [u8; 0],
}
pub type Pango2HbFont = _Pango2HbFont;
extern "C" {
    pub fn pango2_hb_font_new(
        face: *mut Pango2HbFace,
        size: ::std::os::raw::c_int,
        features: *mut hb_feature_t,
        n_features: ::std::os::raw::c_uint,
        variations: *mut hb_variation_t,
        n_variations: ::std::os::raw::c_uint,
        gravity: Pango2Gravity,
        dpi: f32,
        ctm: *const Pango2Matrix,
    ) -> *mut Pango2HbFont;
}
extern "C" {
    pub fn pango2_hb_font_new_for_description(
        face: *mut Pango2HbFace,
        description: *const Pango2FontDescription,
        dpi: f32,
        ctm: *const Pango2Matrix,
    ) -> *mut Pango2HbFont;
}
extern "C" {
    pub fn pango2_hb_font_get_features(
        self_: *mut Pango2HbFont,
        n_features: *mut ::std::os::raw::c_uint,
    ) -> *const hb_feature_t;
}
extern "C" {
    pub fn pango2_hb_font_get_variations(
        self_: *mut Pango2HbFont,
        n_variations: *mut ::std::os::raw::c_uint,
    ) -> *const hb_variation_t;
}
extern "C" {
    pub fn pango2_run_get_item(run: *mut Pango2Run) -> *mut Pango2Item;
}
extern "C" {
    pub fn pango2_run_get_glyphs(run: *mut Pango2Run) -> *mut Pango2GlyphString;
}
extern "C" {
    pub fn pango2_run_get_extents(
        run: *mut Pango2Run,
        trim: Pango2LeadingTrim,
        ink_rect: *mut Pango2Rectangle,
        logical_rect: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_line_get_type() -> GType;
}
extern "C" {
    pub fn pango2_line_copy(line: *mut Pango2Line) -> *mut Pango2Line;
}
extern "C" {
    pub fn pango2_line_free(line: *mut Pango2Line);
}
extern "C" {
    pub fn pango2_line_justify(
        line: *mut Pango2Line,
        width: ::std::os::raw::c_int,
    ) -> *mut Pango2Line;
}
extern "C" {
    pub fn pango2_line_get_run_count(line: *mut Pango2Line) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_line_get_runs(line: *mut Pango2Line) -> *mut *mut Pango2Run;
}
extern "C" {
    pub fn pango2_line_get_text(
        line: *mut Pango2Line,
        start_index: *mut ::std::os::raw::c_int,
        length: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pango2_line_get_start_index(line: *mut Pango2Line) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_line_get_length(line: *mut Pango2Line) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_line_get_log_attrs(
        line: *mut Pango2Line,
        start_offset: *mut ::std::os::raw::c_int,
        n_attrs: *mut ::std::os::raw::c_int,
    ) -> *const Pango2LogAttr;
}
extern "C" {
    pub fn pango2_line_is_wrapped(line: *mut Pango2Line) -> gboolean;
}
extern "C" {
    pub fn pango2_line_is_ellipsized(line: *mut Pango2Line) -> gboolean;
}
extern "C" {
    pub fn pango2_line_is_hyphenated(line: *mut Pango2Line) -> gboolean;
}
extern "C" {
    pub fn pango2_line_is_justified(line: *mut Pango2Line) -> gboolean;
}
extern "C" {
    pub fn pango2_line_is_paragraph_start(line: *mut Pango2Line) -> gboolean;
}
extern "C" {
    pub fn pango2_line_is_paragraph_end(line: *mut Pango2Line) -> gboolean;
}
extern "C" {
    pub fn pango2_line_get_resolved_direction(line: *mut Pango2Line) -> Pango2Direction;
}
extern "C" {
    pub fn pango2_line_get_extents(
        line: *mut Pango2Line,
        ink_rect: *mut Pango2Rectangle,
        logical_rect: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_line_get_trimmed_extents(
        line: *mut Pango2Line,
        trim: Pango2LeadingTrim,
        logical_rect: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_line_index_to_pos(
        line: *mut Pango2Line,
        idx: ::std::os::raw::c_int,
        pos: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_line_index_to_x(
        line: *mut Pango2Line,
        idx: ::std::os::raw::c_int,
        trailing: ::std::os::raw::c_int,
        x_pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_line_x_to_index(
        line: *mut Pango2Line,
        x: ::std::os::raw::c_int,
        idx: *mut ::std::os::raw::c_int,
        trailing: *mut ::std::os::raw::c_int,
    ) -> gboolean;
}
extern "C" {
    pub fn pango2_line_get_cursor_pos(
        line: *mut Pango2Line,
        idx: ::std::os::raw::c_int,
        strong_pos: *mut Pango2Rectangle,
        weak_pos: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_line_get_caret_pos(
        line: *mut Pango2Line,
        idx: ::std::os::raw::c_int,
        strong_pos: *mut Pango2Rectangle,
        weak_pos: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_lines_get_type() -> GType;
}
extern "C" {
    pub fn pango2_lines_new() -> *mut Pango2Lines;
}
extern "C" {
    pub fn pango2_lines_get_serial(lines: *mut Pango2Lines) -> guint;
}
extern "C" {
    pub fn pango2_lines_add_line(
        lines: *mut Pango2Lines,
        line: *mut Pango2Line,
        line_x: ::std::os::raw::c_int,
        line_y: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_lines_get_line_count(lines: *mut Pango2Lines) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_lines_get_lines(lines: *mut Pango2Lines) -> *mut *mut Pango2Line;
}
extern "C" {
    pub fn pango2_lines_get_line_position(
        lines: *mut Pango2Lines,
        num: ::std::os::raw::c_int,
        line_x: *mut ::std::os::raw::c_int,
        line_y: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_lines_get_iter(lines: *mut Pango2Lines) -> *mut Pango2LineIter;
}
extern "C" {
    pub fn pango2_lines_get_extents(
        lines: *mut Pango2Lines,
        ink_rect: *mut Pango2Rectangle,
        logical_rect: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_lines_get_trimmed_extents(
        lines: *mut Pango2Lines,
        trim: Pango2LeadingTrim,
        ink_rect: *mut Pango2Rectangle,
        logical_rect: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_lines_get_size(
        lines: *mut Pango2Lines,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_lines_get_baseline(lines: *mut Pango2Lines) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_lines_get_x_ranges(
        lines: *mut Pango2Lines,
        line: *mut Pango2Line,
        start_line: *mut Pango2Line,
        start_index: ::std::os::raw::c_int,
        end_line: *mut Pango2Line,
        end_index: ::std::os::raw::c_int,
        ranges: *mut *mut ::std::os::raw::c_int,
        n_ranges: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_lines_get_unknown_glyphs_count(lines: *mut Pango2Lines) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_lines_is_wrapped(lines: *mut Pango2Lines) -> gboolean;
}
extern "C" {
    pub fn pango2_lines_is_ellipsized(lines: *mut Pango2Lines) -> gboolean;
}
extern "C" {
    pub fn pango2_lines_is_hyphenated(lines: *mut Pango2Lines) -> gboolean;
}
extern "C" {
    pub fn pango2_lines_index_to_line(
        lines: *mut Pango2Lines,
        idx: ::std::os::raw::c_int,
        line: *mut *mut Pango2Line,
        line_no: *mut ::std::os::raw::c_int,
        x_offset: *mut ::std::os::raw::c_int,
        y_offset: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_lines_pos_to_line(
        lines: *mut Pango2Lines,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        line_x: *mut ::std::os::raw::c_int,
        line_y: *mut ::std::os::raw::c_int,
    ) -> *mut Pango2Line;
}
extern "C" {
    pub fn pango2_lines_index_to_pos(
        lines: *mut Pango2Lines,
        line: *mut Pango2Line,
        idx: ::std::os::raw::c_int,
        pos: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_lines_pos_to_index(
        lines: *mut Pango2Lines,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        idx: *mut ::std::os::raw::c_int,
        trailing: *mut ::std::os::raw::c_int,
    ) -> *mut Pango2Line;
}
extern "C" {
    pub fn pango2_lines_get_cursor_pos(
        lines: *mut Pango2Lines,
        line: *mut Pango2Line,
        idx: ::std::os::raw::c_int,
        strong_pos: *mut Pango2Rectangle,
        weak_pos: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_lines_get_caret_pos(
        lines: *mut Pango2Lines,
        line: *mut Pango2Line,
        idx: ::std::os::raw::c_int,
        strong_pos: *mut Pango2Rectangle,
        weak_pos: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_lines_move_cursor(
        lines: *mut Pango2Lines,
        strong: gboolean,
        line: *mut Pango2Line,
        idx: ::std::os::raw::c_int,
        trailing: ::std::os::raw::c_int,
        direction: ::std::os::raw::c_int,
        new_line: *mut *mut Pango2Line,
        new_idx: *mut ::std::os::raw::c_int,
        new_trailing: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_lines_serialize(lines: *mut Pango2Lines) -> *mut GBytes;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2TabArray {
    _unused: [u8; 0],
}
pub type Pango2TabArray = _Pango2TabArray;
pub const Pango2TabAlign_PANGO2_TAB_LEFT: Pango2TabAlign = 0;
pub const Pango2TabAlign_PANGO2_TAB_RIGHT: Pango2TabAlign = 1;
pub const Pango2TabAlign_PANGO2_TAB_CENTER: Pango2TabAlign = 2;
pub const Pango2TabAlign_PANGO2_TAB_DECIMAL: Pango2TabAlign = 3;
#[doc = " Pango2TabAlign:\n @PANGO2_TAB_LEFT: the text appears to the right of the tab stop position\n @PANGO2_TAB_RIGHT: the text appears to the left of the tab stop position\n   until the available space is filled.\n @PANGO2_TAB_CENTER: the text is centered at the tab stop position\n   until the available space is filled.\n @PANGO2_TAB_DECIMAL: text before the first occurrence of the decimal point\n   character appears to the left of the tab stop position (until the available\n   space is filled), the rest to the right.\n\n `Pango2TabAlign` specifies where the text appears relative to the tab stop\n position."]
pub type Pango2TabAlign = ::std::os::raw::c_uint;
pub const Pango2TabPositions_PANGO2_TAB_POSITIONS_DEFAULT: Pango2TabPositions = 0;
pub const Pango2TabPositions_PANGO2_TAB_POSITIONS_PIXELS: Pango2TabPositions = 1;
pub const Pango2TabPositions_PANGO2_TAB_POSITIONS_SPACES: Pango2TabPositions = 2;
#[doc = " Pango2TabPositions:\n @PANGO2_TAB_POSITIONS_DEFAULT: Positions are in Pango units\n @PANGO2_TAB_POSITIONS_PIXELS: Positions are in pixels\n @PANGO2_TAB_POSITIONS_SPACES: Positions are in spaces\n\n `Pango2TabPositions` specifies the unit for tab positions."]
pub type Pango2TabPositions = ::std::os::raw::c_uint;
extern "C" {
    pub fn pango2_tab_array_get_type() -> GType;
}
extern "C" {
    pub fn pango2_tab_array_new(
        initial_size: ::std::os::raw::c_int,
        positions: Pango2TabPositions,
    ) -> *mut Pango2TabArray;
}
extern "C" {
    pub fn pango2_tab_array_new_with_positions(
        size: ::std::os::raw::c_int,
        positions: Pango2TabPositions,
        first_alignment: Pango2TabAlign,
        first_position: ::std::os::raw::c_int,
        ...
    ) -> *mut Pango2TabArray;
}
extern "C" {
    pub fn pango2_tab_array_copy(src: *mut Pango2TabArray) -> *mut Pango2TabArray;
}
extern "C" {
    pub fn pango2_tab_array_free(tab_array: *mut Pango2TabArray);
}
extern "C" {
    pub fn pango2_tab_array_get_size(tab_array: *mut Pango2TabArray) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_tab_array_resize(tab_array: *mut Pango2TabArray, new_size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pango2_tab_array_set_tab(
        tab_array: *mut Pango2TabArray,
        tab_index: ::std::os::raw::c_int,
        alignment: Pango2TabAlign,
        location: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_tab_array_get_tab(
        tab_array: *mut Pango2TabArray,
        tab_index: ::std::os::raw::c_int,
        alignment: *mut Pango2TabAlign,
        location: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_tab_array_get_tabs(
        tab_array: *mut Pango2TabArray,
        alignments: *mut *mut Pango2TabAlign,
        locations: *mut *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_tab_array_get_positions(tab_array: *mut Pango2TabArray) -> Pango2TabPositions;
}
extern "C" {
    pub fn pango2_tab_array_set_positions(
        tab_array: *mut Pango2TabArray,
        positions: Pango2TabPositions,
    );
}
extern "C" {
    pub fn pango2_tab_array_to_string(
        tab_array: *mut Pango2TabArray,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pango2_tab_array_from_string(text: *const ::std::os::raw::c_char)
        -> *mut Pango2TabArray;
}
extern "C" {
    pub fn pango2_tab_array_set_decimal_point(
        tab_array: *mut Pango2TabArray,
        tab_index: ::std::os::raw::c_int,
        decimal_point: gunichar,
    );
}
extern "C" {
    pub fn pango2_tab_array_get_decimal_point(
        tab_array: *mut Pango2TabArray,
        tab_index: ::std::os::raw::c_int,
    ) -> gunichar;
}
extern "C" {
    pub fn pango2_tab_array_sort(tab_array: *mut Pango2TabArray);
}
extern "C" {
    pub fn pango2_layout_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2Layout {
    _unused: [u8; 0],
}
pub type Pango2Layout = _Pango2Layout;
extern "C" {
    pub fn pango2_layout_new(context: *mut Pango2Context) -> *mut Pango2Layout;
}
extern "C" {
    pub fn pango2_layout_copy(layout: *mut Pango2Layout) -> *mut Pango2Layout;
}
extern "C" {
    pub fn pango2_layout_get_serial(layout: *mut Pango2Layout) -> guint;
}
extern "C" {
    pub fn pango2_layout_get_context(layout: *mut Pango2Layout) -> *mut Pango2Context;
}
extern "C" {
    pub fn pango2_layout_context_changed(layout: *mut Pango2Layout);
}
extern "C" {
    pub fn pango2_layout_set_text(
        layout: *mut Pango2Layout,
        text: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_layout_get_text(layout: *mut Pango2Layout) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pango2_layout_set_markup(
        layout: *mut Pango2Layout,
        markup: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_layout_get_character_count(layout: *mut Pango2Layout) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_layout_set_attributes(layout: *mut Pango2Layout, attrs: *mut Pango2AttrList);
}
extern "C" {
    pub fn pango2_layout_get_attributes(layout: *mut Pango2Layout) -> *mut Pango2AttrList;
}
extern "C" {
    pub fn pango2_layout_set_font_description(
        layout: *mut Pango2Layout,
        desc: *const Pango2FontDescription,
    );
}
extern "C" {
    pub fn pango2_layout_get_font_description(
        layout: *mut Pango2Layout,
    ) -> *const Pango2FontDescription;
}
extern "C" {
    pub fn pango2_layout_set_line_height(layout: *mut Pango2Layout, line_height: f32);
}
extern "C" {
    pub fn pango2_layout_get_line_height(layout: *mut Pango2Layout) -> f32;
}
extern "C" {
    pub fn pango2_layout_set_spacing(layout: *mut Pango2Layout, spacing: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pango2_layout_get_spacing(layout: *mut Pango2Layout) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_layout_set_width(layout: *mut Pango2Layout, width: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pango2_layout_get_width(layout: *mut Pango2Layout) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_layout_set_height(layout: *mut Pango2Layout, height: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pango2_layout_get_height(layout: *mut Pango2Layout) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_layout_set_tabs(layout: *mut Pango2Layout, tabs: *mut Pango2TabArray);
}
extern "C" {
    pub fn pango2_layout_get_tabs(layout: *mut Pango2Layout) -> *mut Pango2TabArray;
}
extern "C" {
    pub fn pango2_layout_set_single_paragraph(
        layout: *mut Pango2Layout,
        single_paragraph: gboolean,
    );
}
extern "C" {
    pub fn pango2_layout_get_single_paragraph(layout: *mut Pango2Layout) -> gboolean;
}
extern "C" {
    pub fn pango2_layout_set_wrap(layout: *mut Pango2Layout, wrap: Pango2WrapMode);
}
extern "C" {
    pub fn pango2_layout_get_wrap(layout: *mut Pango2Layout) -> Pango2WrapMode;
}
extern "C" {
    pub fn pango2_layout_set_indent(layout: *mut Pango2Layout, indent: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pango2_layout_get_indent(layout: *mut Pango2Layout) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_layout_set_alignment(layout: *mut Pango2Layout, alignment: Pango2Alignment);
}
extern "C" {
    pub fn pango2_layout_get_alignment(layout: *mut Pango2Layout) -> Pango2Alignment;
}
extern "C" {
    pub fn pango2_layout_set_ellipsize(layout: *mut Pango2Layout, ellipsize: Pango2EllipsizeMode);
}
extern "C" {
    pub fn pango2_layout_get_ellipsize(layout: *mut Pango2Layout) -> Pango2EllipsizeMode;
}
extern "C" {
    pub fn pango2_layout_set_auto_dir(layout: *mut Pango2Layout, auto_dir: gboolean);
}
extern "C" {
    pub fn pango2_layout_get_auto_dir(layout: *mut Pango2Layout) -> gboolean;
}
extern "C" {
    pub fn pango2_layout_get_lines(layout: *mut Pango2Layout) -> *mut Pango2Lines;
}
extern "C" {
    pub fn pango2_layout_get_iter(layout: *mut Pango2Layout) -> *mut Pango2LineIter;
}
extern "C" {
    pub fn pango2_layout_get_log_attrs(
        layout: *mut Pango2Layout,
        n_attrs: *mut ::std::os::raw::c_int,
    ) -> *const Pango2LogAttr;
}
pub const Pango2LayoutSerializeFlags_PANGO2_LAYOUT_SERIALIZE_DEFAULT: Pango2LayoutSerializeFlags =
    0;
pub const Pango2LayoutSerializeFlags_PANGO2_LAYOUT_SERIALIZE_CONTEXT: Pango2LayoutSerializeFlags =
    1;
pub const Pango2LayoutSerializeFlags_PANGO2_LAYOUT_SERIALIZE_OUTPUT: Pango2LayoutSerializeFlags = 2;
pub type Pango2LayoutSerializeFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn pango2_layout_serialize(
        layout: *mut Pango2Layout,
        flags: Pango2LayoutSerializeFlags,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn pango2_layout_write_to_file(
        layout: *mut Pango2Layout,
        filename: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
pub const Pango2LayoutDeserializeFlags_PANGO2_LAYOUT_DESERIALIZE_DEFAULT:
    Pango2LayoutDeserializeFlags = 0;
pub const Pango2LayoutDeserializeFlags_PANGO2_LAYOUT_DESERIALIZE_CONTEXT:
    Pango2LayoutDeserializeFlags = 1;
pub type Pango2LayoutDeserializeFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn pango2_layout_deserialize_error_quark() -> GQuark;
}
extern "C" {
    pub fn pango2_layout_deserialize(
        context: *mut Pango2Context,
        bytes: *mut GBytes,
        flags: Pango2LayoutDeserializeFlags,
        error: *mut *mut GError,
    ) -> *mut Pango2Layout;
}
extern "C" {
    pub fn pango2_line_breaker_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2LineBreaker {
    _unused: [u8; 0],
}
pub type Pango2LineBreaker = _Pango2LineBreaker;
extern "C" {
    pub fn pango2_line_breaker_new(context: *mut Pango2Context) -> *mut Pango2LineBreaker;
}
extern "C" {
    pub fn pango2_line_breaker_get_context(self_: *mut Pango2LineBreaker) -> *mut Pango2Context;
}
extern "C" {
    pub fn pango2_line_breaker_set_tabs(self_: *mut Pango2LineBreaker, tabs: *mut Pango2TabArray);
}
extern "C" {
    pub fn pango2_line_breaker_get_tabs(self_: *mut Pango2LineBreaker) -> *mut Pango2TabArray;
}
extern "C" {
    pub fn pango2_line_breaker_set_base_dir(
        self_: *mut Pango2LineBreaker,
        direction: Pango2Direction,
    );
}
extern "C" {
    pub fn pango2_line_breaker_get_base_dir(self_: *mut Pango2LineBreaker) -> Pango2Direction;
}
extern "C" {
    pub fn pango2_line_breaker_add_text(
        self_: *mut Pango2LineBreaker,
        text: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        attrs: *mut Pango2AttrList,
    );
}
extern "C" {
    pub fn pango2_line_breaker_get_direction(self_: *mut Pango2LineBreaker) -> Pango2Direction;
}
extern "C" {
    pub fn pango2_line_breaker_has_line(self_: *mut Pango2LineBreaker) -> gboolean;
}
extern "C" {
    pub fn pango2_line_breaker_next_line(
        self_: *mut Pango2LineBreaker,
        x: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        wrap: Pango2WrapMode,
        ellipsize: Pango2EllipsizeMode,
    ) -> *mut Pango2Line;
}
extern "C" {
    pub fn pango2_line_breaker_undo_line(
        self_: *mut Pango2LineBreaker,
        line: *mut Pango2Line,
    ) -> gboolean;
}
extern "C" {
    pub fn pango2_line_iter_get_type() -> GType;
}
extern "C" {
    pub fn pango2_line_iter_copy(iter: *mut Pango2LineIter) -> *mut Pango2LineIter;
}
extern "C" {
    pub fn pango2_line_iter_free(iter: *mut Pango2LineIter);
}
extern "C" {
    pub fn pango2_line_iter_get_lines(iter: *mut Pango2LineIter) -> *mut Pango2Lines;
}
extern "C" {
    pub fn pango2_line_iter_get_line(iter: *mut Pango2LineIter) -> *mut Pango2Line;
}
extern "C" {
    pub fn pango2_line_iter_at_last_line(iter: *mut Pango2LineIter) -> gboolean;
}
extern "C" {
    pub fn pango2_line_iter_get_run(iter: *mut Pango2LineIter) -> *mut Pango2Run;
}
extern "C" {
    pub fn pango2_line_iter_get_index(iter: *mut Pango2LineIter) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_line_iter_next_line(iter: *mut Pango2LineIter) -> gboolean;
}
extern "C" {
    pub fn pango2_line_iter_next_run(iter: *mut Pango2LineIter) -> gboolean;
}
extern "C" {
    pub fn pango2_line_iter_next_cluster(iter: *mut Pango2LineIter) -> gboolean;
}
extern "C" {
    pub fn pango2_line_iter_next_char(iter: *mut Pango2LineIter) -> gboolean;
}
extern "C" {
    pub fn pango2_line_iter_get_layout_extents(
        iter: *mut Pango2LineIter,
        ink_rect: *mut Pango2Rectangle,
        logical_rect: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_line_iter_get_line_extents(
        iter: *mut Pango2LineIter,
        ink_rect: *mut Pango2Rectangle,
        logical_rect: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_line_iter_get_trimmed_line_extents(
        iter: *mut Pango2LineIter,
        trim: Pango2LeadingTrim,
        logical_rect: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_line_iter_get_run_extents(
        iter: *mut Pango2LineIter,
        ink_rect: *mut Pango2Rectangle,
        logical_rect: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_line_iter_get_cluster_extents(
        iter: *mut Pango2LineIter,
        ink_rect: *mut Pango2Rectangle,
        logical_rect: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_line_iter_get_char_extents(
        iter: *mut Pango2LineIter,
        logical_rect: *mut Pango2Rectangle,
    );
}
extern "C" {
    pub fn pango2_line_iter_get_line_baseline(iter: *mut Pango2LineIter) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_line_iter_get_run_baseline(iter: *mut Pango2LineIter) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_markup_parser_new(accel_marker: gunichar) -> *mut GMarkupParseContext;
}
extern "C" {
    pub fn pango2_markup_parser_finish(
        context: *mut GMarkupParseContext,
        attr_list: *mut *mut Pango2AttrList,
        text: *mut *mut ::std::os::raw::c_char,
        accel_char: *mut gunichar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn pango2_parse_markup(
        markup_text: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        accel_marker: gunichar,
        attr_list: *mut *mut Pango2AttrList,
        text: *mut *mut ::std::os::raw::c_char,
        accel_char: *mut gunichar,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[doc = " Pango2Renderer:\n\n `Pango2Renderer` is a base class for objects that can render text\n provided as `Pango2GlyphString` or `Pango2Layout`.\n\n By subclassing `Pango2Renderer` and overriding operations such as\n @draw_glyphs and @draw_rectangle, renderers for particular font\n backends and destinations can be created."]
pub type Pango2Renderer = _Pango2Renderer;
pub const Pango2RenderPart_PANGO2_RENDER_PART_FOREGROUND: Pango2RenderPart = 0;
pub const Pango2RenderPart_PANGO2_RENDER_PART_BACKGROUND: Pango2RenderPart = 1;
pub const Pango2RenderPart_PANGO2_RENDER_PART_UNDERLINE: Pango2RenderPart = 2;
pub const Pango2RenderPart_PANGO2_RENDER_PART_STRIKETHROUGH: Pango2RenderPart = 3;
pub const Pango2RenderPart_PANGO2_RENDER_PART_OVERLINE: Pango2RenderPart = 4;
pub type Pango2RenderPart = ::std::os::raw::c_uint;
#[doc = " Pango2Renderer:\n\n `Pango2Renderer` is a base class for objects that can render text\n provided as `Pango2GlyphString` or `Pango2Layout`.\n\n By subclassing `Pango2Renderer` and overriding operations such as\n @draw_glyphs and @draw_rectangle, renderers for particular font\n backends and destinations can be created."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2Renderer {
    pub parent_instance: GObject,
}
#[test]
fn bindgen_test_layout__Pango2Renderer() {
    const UNINIT: ::std::mem::MaybeUninit<_Pango2Renderer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Pango2Renderer>(),
        24usize,
        concat!("Size of: ", stringify!(_Pango2Renderer))
    );
    assert_eq!(
        ::std::mem::align_of::<_Pango2Renderer>(),
        8usize,
        concat!("Alignment of ", stringify!(_Pango2Renderer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pango2Renderer),
            "::",
            stringify!(parent_instance)
        )
    );
}
extern "C" {
    pub fn pango2_renderer_get_type() -> GType;
}
extern "C" {
    pub fn pango2_renderer_draw_lines(
        renderer: *mut Pango2Renderer,
        lines: *mut Pango2Lines,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_renderer_draw_line(
        renderer: *mut Pango2Renderer,
        line: *mut Pango2Line,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_renderer_draw_glyphs(
        renderer: *mut Pango2Renderer,
        font: *mut Pango2Font,
        glyphs: *mut Pango2GlyphString,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_renderer_draw_run(
        renderer: *mut Pango2Renderer,
        text: *const ::std::os::raw::c_char,
        run: *mut Pango2Run,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_renderer_draw_rectangle(
        renderer: *mut Pango2Renderer,
        part: Pango2RenderPart,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_renderer_draw_styled_line(
        renderer: *mut Pango2Renderer,
        part: Pango2RenderPart,
        style: Pango2LineStyle,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_renderer_draw_error_underline(
        renderer: *mut Pango2Renderer,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_renderer_draw_trapezoid(
        renderer: *mut Pango2Renderer,
        part: Pango2RenderPart,
        y1_: f64,
        x11: f64,
        x21: f64,
        y2: f64,
        x12: f64,
        x22: f64,
    );
}
extern "C" {
    pub fn pango2_renderer_draw_glyph(
        renderer: *mut Pango2Renderer,
        font: *mut Pango2Font,
        glyph: Pango2Glyph,
        x: f64,
        y: f64,
    );
}
extern "C" {
    pub fn pango2_renderer_activate(renderer: *mut Pango2Renderer);
}
extern "C" {
    pub fn pango2_renderer_deactivate(renderer: *mut Pango2Renderer);
}
extern "C" {
    pub fn pango2_renderer_part_changed(renderer: *mut Pango2Renderer, part: Pango2RenderPart);
}
extern "C" {
    pub fn pango2_renderer_set_color(
        renderer: *mut Pango2Renderer,
        part: Pango2RenderPart,
        color: *const Pango2Color,
    );
}
extern "C" {
    pub fn pango2_renderer_get_color(
        renderer: *mut Pango2Renderer,
        part: Pango2RenderPart,
    ) -> *mut Pango2Color;
}
extern "C" {
    pub fn pango2_renderer_set_matrix(renderer: *mut Pango2Renderer, matrix: *const Pango2Matrix);
}
extern "C" {
    pub fn pango2_renderer_get_matrix(renderer: *mut Pango2Renderer) -> *const Pango2Matrix;
}
extern "C" {
    pub fn pango2_renderer_get_lines(renderer: *mut Pango2Renderer) -> *mut Pango2Lines;
}
extern "C" {
    pub fn pango2_renderer_get_layout_line(renderer: *mut Pango2Renderer) -> *mut Pango2Line;
}
extern "C" {
    pub fn pango2_renderer_get_context(renderer: *mut Pango2Renderer) -> *mut Pango2Context;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2UserFont {
    _unused: [u8; 0],
}
pub type Pango2UserFont = _Pango2UserFont;
extern "C" {
    pub fn pango2_user_face_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pango2UserFace {
    _unused: [u8; 0],
}
pub type Pango2UserFace = _Pango2UserFace;
pub type Pango2UserFaceGetFontInfoFunc = ::std::option::Option<
    unsafe extern "C" fn(
        face: *mut Pango2UserFace,
        size: ::std::os::raw::c_int,
        extents: *mut hb_font_extents_t,
        user_data: gpointer,
    ) -> gboolean,
>;
pub type Pango2UserFaceUnicodeToGlyphFunc = ::std::option::Option<
    unsafe extern "C" fn(
        face: *mut Pango2UserFace,
        unicode: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
        user_data: gpointer,
    ) -> gboolean,
>;
pub type Pango2UserFaceGetGlyphInfoFunc = ::std::option::Option<
    unsafe extern "C" fn(
        face: *mut Pango2UserFace,
        size: ::std::os::raw::c_int,
        glyph: hb_codepoint_t,
        extents: *mut hb_glyph_extents_t,
        h_advance: *mut hb_position_t,
        v_advance: *mut hb_position_t,
        is_color_glyph: *mut gboolean,
        user_data: gpointer,
    ) -> gboolean,
>;
pub type Pango2UserFaceTextToGlyphFunc = ::std::option::Option<
    unsafe extern "C" fn(
        face: *mut Pango2UserFace,
        size: ::std::os::raw::c_int,
        text: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        analysis: *const Pango2Analysis,
        glyphs: *mut Pango2GlyphString,
        flags: Pango2ShapeFlags,
        user_data: gpointer,
    ) -> gboolean,
>;
pub type Pango2UserFaceRenderGlyphFunc = ::std::option::Option<
    unsafe extern "C" fn(
        face: *mut Pango2UserFace,
        size: ::std::os::raw::c_int,
        glyph: hb_codepoint_t,
        user_data: gpointer,
        backend_id: *const ::std::os::raw::c_char,
        backend_data: gpointer,
    ) -> gboolean,
>;
extern "C" {
    pub fn pango2_user_face_new(
        font_info_func: Pango2UserFaceGetFontInfoFunc,
        glyph_func: Pango2UserFaceUnicodeToGlyphFunc,
        glyph_info_func: Pango2UserFaceGetGlyphInfoFunc,
        shape_func: Pango2UserFaceTextToGlyphFunc,
        render_func: Pango2UserFaceRenderGlyphFunc,
        user_data: gpointer,
        destroy: GDestroyNotify,
        name: *const ::std::os::raw::c_char,
        description: *const Pango2FontDescription,
    ) -> *mut Pango2UserFace;
}
extern "C" {
    pub fn pango2_user_font_get_type() -> GType;
}
extern "C" {
    pub fn pango2_user_font_new(
        face: *mut Pango2UserFace,
        size: ::std::os::raw::c_int,
        gravity: Pango2Gravity,
        dpi: f32,
        ctm: *const Pango2Matrix,
    ) -> *mut Pango2UserFont;
}
extern "C" {
    pub fn pango2_user_font_new_for_description(
        face: *mut Pango2UserFace,
        description: *const Pango2FontDescription,
        dpi: f32,
        ctm: *const Pango2Matrix,
    ) -> *mut Pango2UserFont;
}
extern "C" {
    pub fn pango2_is_zero_width(ch: gunichar) -> gboolean;
}
extern "C" {
    pub fn pango2_find_paragraph_boundary(
        text: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        paragraph_delimiter_index: *mut ::std::os::raw::c_int,
        next_paragraph_start: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pango2_version() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pango2_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pango2_version_check(
        required_major: ::std::os::raw::c_int,
        required_minor: ::std::os::raw::c_int,
        required_micro: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_font_options {
    _unused: [u8; 0],
}
#[doc = " cairo_font_options_t:\n\n An opaque structure holding all options that are used when\n rendering fonts.\n\n Individual features of a #cairo_font_options_t can be set or\n accessed using functions named\n <function>cairo_font_options_set_<emphasis>feature_name</emphasis>()</function> and\n <function>cairo_font_options_get_<emphasis>feature_name</emphasis>()</function>, like\n cairo_font_options_set_antialias() and\n cairo_font_options_get_antialias().\n\n New features may be added to a #cairo_font_options_t in the\n future.  For this reason, cairo_font_options_copy(),\n cairo_font_options_equal(), cairo_font_options_merge(), and\n cairo_font_options_hash() should be used to copy, check\n for equality, merge, or compute a hash value of\n #cairo_font_options_t objects.\n\n Since: 1.0"]
pub type cairo_font_options_t = _cairo_font_options;
extern "C" {
    pub fn pango2_cairo_create_context(cr: *mut cairo_t) -> *mut Pango2Context;
}
extern "C" {
    pub fn pango2_cairo_update_context(cr: *mut cairo_t, context: *mut Pango2Context);
}
extern "C" {
    pub fn pango2_cairo_create_layout(cr: *mut cairo_t) -> *mut Pango2Layout;
}
extern "C" {
    pub fn pango2_cairo_update_layout(cr: *mut cairo_t, layout: *mut Pango2Layout);
}
extern "C" {
    pub fn pango2_cairo_context_set_font_options(
        context: *mut Pango2Context,
        options: *const cairo_font_options_t,
    );
}
extern "C" {
    pub fn pango2_cairo_context_get_font_options(
        context: *mut Pango2Context,
    ) -> *const cairo_font_options_t;
}
extern "C" {
    pub fn pango2_cairo_font_set_font_options(
        font: *mut Pango2Font,
        options: *const cairo_font_options_t,
    );
}
extern "C" {
    pub fn pango2_cairo_font_get_font_options(font: *mut Pango2Font)
        -> *const cairo_font_options_t;
}
extern "C" {
    pub fn pango2_cairo_show_glyph_string(
        cr: *mut cairo_t,
        font: *mut Pango2Font,
        glyphs: *mut Pango2GlyphString,
    );
}
extern "C" {
    pub fn pango2_cairo_show_color_glyph_string(
        cr: *mut cairo_t,
        font: *mut Pango2Font,
        palette: GQuark,
        glyphs: *mut Pango2GlyphString,
    );
}
extern "C" {
    pub fn pango2_cairo_show_run(
        cr: *mut cairo_t,
        text: *const ::std::os::raw::c_char,
        run: *mut Pango2Run,
    );
}
extern "C" {
    pub fn pango2_cairo_show_line(cr: *mut cairo_t, line: *mut Pango2Line);
}
extern "C" {
    pub fn pango2_cairo_show_lines(cr: *mut cairo_t, lines: *mut Pango2Lines);
}
extern "C" {
    pub fn pango2_cairo_show_layout(cr: *mut cairo_t, layout: *mut Pango2Layout);
}
extern "C" {
    pub fn pango2_cairo_glyph_string_path(
        cr: *mut cairo_t,
        font: *mut Pango2Font,
        glyphs: *mut Pango2GlyphString,
    );
}
extern "C" {
    pub fn pango2_cairo_run_path(
        cr: *mut cairo_t,
        text: *const ::std::os::raw::c_char,
        run: *mut Pango2Run,
    );
}
extern "C" {
    pub fn pango2_cairo_line_path(cr: *mut cairo_t, line: *mut Pango2Line);
}
extern "C" {
    pub fn pango2_cairo_lines_path(cr: *mut cairo_t, lines: *mut Pango2Lines);
}
extern "C" {
    pub fn pango2_cairo_layout_path(cr: *mut cairo_t, layout: *mut Pango2Layout);
}
